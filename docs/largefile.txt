ank anhaskanali iravichakum`
# 👇️ delete node_modules and package-lock.json
# 👇️ clean npm cache
npm cache clean --force


VS config


 {
    "strings": true
  },
  "css.lint.unknownAtRules": "ignore",
  "editor.codeActionsOnSave": {
    "source.fixAll.eslint": true
  },
  "editor.defaultFormatter": "esbenp.prettier-vscode",
  "editor.formatOnSave": true,
  "files.insertFinalNewline": true,
  "prettier.singleQuote": true,
  "prettier.jsxSingleQuote": false,
  "html.completion.attributeDefaultValue": "doublequotes",
  "prettier.trailingComma": "none",
  "prettier.printWidth": 80
}

we can also create a file in our directory called .prettierrc in which we can write 
{
“singleQuote”:true,
……. modify what we need from https://prettier.io/docs/en/options.html documentation 
}
we can fo file-> preferences->user preferences
cntr+r shows recently opened folders
cntr+` toggle terminal

other keyboards
in the browser cntr+shift+c -> opens dev tools

Some basic concepts of a computer
The CPU, or Central Processing Unit, is a core component of a computer system that performs most of the processing tasks in a computer. It is also known as the "brain" of the computer. The CPU interprets instructions from software programs and performs the necessary calculations and operations to execute those instructions.
The CPU is responsible for managing and executing all of the computer's operations, including running programs, managing memory, handling input and output, and performing mathematical calculations. It consists of multiple components, including the arithmetic logic unit (ALU) and the control unit (CU), which work together to carry out instructions.
The speed and performance of a computer's CPU is an important factor in determining its overall performance. Faster CPUs with more cores can handle more complex tasks and run programs more quickly than slower CPUs with fewer cores.

CSS box model
is a fundamental concept in web design, that describes how html elements are displayed in a web page. every HTML el is represented by a rectangular box which  has 4 important properties
-content(text img other html elements)
-padding(the space between the content and the border of the box)
-Border(a border around the padding and content of the box)
-Margin(the space outside the border of the box)


Sass and SCSS are both CSS pre-processors that allow you to write CSS in a more efficient and organized way. While they share some similarities, there are a few differences between the two.

Sass-indentation to indicate nesting
SCSS-curly braces 
variables declaration 
in sass- and SCSS-> witha $ sign, can use arithmetic operators and %
// Sass
$width: 100px;
$margin: $width / 2;

// Less with a @ sign
@width: 100px;
@margin: @width / 2;

mixins
// Sass and SCSS
@mixin border-radius($radius: 5px) {
  border-radius: $radius;
}

.box {
  @include border-radius;
}

// Less
.border-radius(@radius: 5px) {
  border-radius: @radius;
}

.box {
  .border-radius();
}
order of arguments of mixins in less must be keeped as they are defined, but in case of sass and scss-> not necessary as long as they are named.

Difference between attribute and property->
To summarize, attributes are defined in HTML, and properties are assigned at runtime using JavaScript. Attributes are static, meaning they cannot be changed once they are set, while properties can be changed dynamically at runtime.
<button class="button">Click Me!</button> class-> attribute, button-> value
document.querySelector('button').disabled = true; -> disabled-> property, true-> value


High-level and low-level programming languages are two broad categories of programming languages, each with its own characteristics and advantages.
High-level programming languages are designed to be easier to read and write, with an emphasis on abstraction and simplicity. They provide a high level of abstraction from the underlying hardware and allow programmers to focus on solving the problem at hand, rather than worrying about low-level details such as memory management or device access. High-level languages typically have a syntax that is similar to natural language and provide many built-in features and libraries that simplify programming tasks.
Examples of high-level programming languages include Java, Python, C#, Ruby, and JavaScript.
Low-level programming languages, on the other hand, are designed to be more closely tied to the hardware of the computer, with an emphasis on control and efficiency. They provide a low level of abstraction and require more manual control over memory management, device access, and other low-level details. Low-level languages are typically more difficult to read and write than high-level languages, but can be more efficient in terms of execution speed and memory usage.
C is a procedural programming language that is often considered a low-level language due to its close relationship with the hardware and its ability to manipulate memory directly.C++, Assembly…
TypeScript is a programming language that is a strict syntactical superset of JavaScript, which means that it builds on top of JavaScript by adding new features and syntax. TypeScript was created by Microsoft and first released in 2012.
TypeScript introduces static typing to JavaScript, which allows developers to catch errors at compile time rather than at runtime. It also supports many of the latest features of JavaScript and provides additional features such as interfaces, classes, enums, and modules.(while const variables can provide some of the same benefits as enums, enums in TypeScript provide a more expressive and type-safe way to define a fixed set of named constants.)
TypeScript is compiled into plain JavaScript, which means that it can run on any browser or platform that supports JavaScript. It is often used for large-scale web applications and provides better maintainability, scalability, and code organization than plain JavaScript.

In the context of JavaScript, the term "runtime" refers to the period of time during which a JavaScript program is executed by a browser or server.
The JavaScript runtime environment is responsible for interpreting and executing the code, managing memory, and providing access to various APIs and libraries. When a JavaScript program is executed, the runtime environment creates a global object and sets up the execution context for the code to run.
Examples of JavaScript runtime environments include web browsers such as Chrome, Firefox, and Safari, as well as server-side environments such as Node.js. The behavior of the runtime environment can vary between different environments, which is why it's important for JavaScript developers to be familiar with the quirks and features of the specific environment they are working with.

Web API, or Application Programming Interface, refers to a set of JavaScript functions and objects that are built into web browsers and can be used to interact with web content and browser functionality.
Some examples of Web APIs provided by web browsers include:
Document Object Model (DOM) API: Allows developers to manipulate and interact with the HTML and XML content of a web page.
XMLHttpRequest (XHR) API: Allows developers to send and receive data from a web server asynchronously without having to reload the entire page.
Geolocation API: Allows web applications to retrieve the geographical location of the user's device.
Canvas API: Allows developers to create and manipulate graphical content on a web page using JavaScript.
Web Storage API: Allows web applications to store data locally on the user's device, even after the user navigates away from the page.
There are many other Web APIs provided by web browsers, and they are constantly evolving and expanding. Developers can use these APIs to create dynamic, interactive, and responsive web applications that can access and leverage the full power of the user's device and web browser.

REST API (Representational State Transfer Application Programming Interface) is a set of rules and conventions that allow different software systems to communicate with each other over the internet.A REST API uses standard HTTP methods such as GET, POST, PUT, PATCH, and DELETE to perform operations on resources, which could be data objects or services. The API typically sends and receives data in a format such as JSON (JavaScript Object Notation) or XML (eXtensible Markup Language).

what is DOM
(DOM stands for Document Object Model, is a hierarchical tree-like structure that represents the HTML elements of a web page as objects, allowing developers to manipulate the elements and their properties.Using the DOM, developers can dynamically change the content and appearance of a web page in response to user interactions or other events. ). The DOM is automatically created when the page loads.
document->elementHTML->->(2branches)1.elementHEAD(->title->simpletext).2.elementBODY->elementSection->1.elh12.elP……..

In JavaScript, the function that runs first behind the scenes to execute all the functions is called the global execution context. When a JavaScript program starts running, the global execution context is created automatically. The global execution context consists of two main components: the creation phase and the execution phase.
During the creation phase, the JavaScript engine initializes the global object (which is the window object in web browsers) and sets up the scope chain and the this keyword. It also scans the code for function and variable declarations and keeps them in memory before executing any code.
During the execution phase, the JavaScript engine starts executing the code line by line, starting from the top of the file. Any functions that are invoked in the code will create their own execution context and add it to the call stack. Once a function has finished executing, its execution context is removed from the call stack and control is returned to the previous execution context.
In summary, the global execution context is the first function that runs behind the scenes to execute all the functions in a JavaScript program. It is responsible for initializing the global object, setting up the scope chain and the this keyword, and creating function and variable declarations before executing any code.


By default, when a browser encounters a <script> tag in an HTML file, it will stop parsing the HTML, first it  fetch and executes the script, and then resume parsing the HTML. This behavior can cause the page to load slower, especially if the script takes a long time to execute or if it interacts with the page's content.. The order in which the JavaScript code is executed depends on the order in which it appears in the HTML file or in external script files, unless the async or defer attributes are used.

If the <script> tag doesn't have either the defer or async attribute, it will execute immediately as soon as it's encountered <script> tag during the parsing of the document.
When a browser encounters a <script> tag in the <head> section of an HTML document, it will start downloading and parsing the JavaScript code immediately. If the JavaScript code manipulates any elements in the <body> section, those elements might not have been loaded yet, which can result in JavaScript errors or unexpected behavior.
To avoid this issue, one common technique is to use the defer attribute on the <script> tag. When this attribute is present, the browser will continue parsing the HTML document while it downloads the JavaScript code, and then execute the JavaScript code after the <body> section has been loaded.
If the <script> tag has the defer attribute, it will execute after the document has been parsed, but before the DOMContentLoaded event is fired. If the <script> tag has the async attribute, it will execute as soon as it is downloaded, which could be before or after the document has finished loading.
to ensure the document is loaded window.onload=function(){...}

Scope in JavaScript refers to the current context of code, which determines the accessibility of variables to JavaScript. where variables(vars and funcs) are declared.
 The two types of scope are local and global: Global variables are those declared outside of a block. Local variables are those declared inside of a block. Local scope can be function scope and block scope.
It is a space where a certain var is declared.
scoping answers the question where vars accessed?
SCOPE OF A VAR is a region of our code where it can be accessed
A closure is the combination of a function bundled together (enclosed) with references to its surrounding state (the lexical environment). In other words, a closure gives you access to an outer function's scope from an inner function.

Hoisting in JavaScript is a mechanism where variables and functions are moved to the top of their respective scopes during the compilation phase before the code is executed. (vars with var keywords are hoisted, but hoisted with the value undefined. if we call them before initialization they show the value undefined, and don't throw reverence error(because they are in a temporal dead zone(starts from the beginning of the current scope until the point where it is defined))) func declaration (which are not declared with var const or let) don't have dead zone, they are accessible unlike func expressions and arrow functions.in case of func expression and arrow functions, if they are declared with var keyword we will get error that is is not a func( because the value is undefined, which is not a func), but with const keyword-> reverence error(because they are in a temporal dead zone).
Some of the rules of ‘clean code’ practices are not to use var keyword and declare the vars on the top of the current scope.
LRACUM VAR CONST LET TARBERUTYUN:
vars declared with the kerword var become properties of window global object (if we write in console window and press enter, we’ll se among other properties and methods the name of our variable, but in case of const/let in we try to log(y===window.y) -> we’ll get false.
in JavaScript, variables declared with the var keyword have function-level scope, which means they are accessible everywhere within the function in which they are declared. However, they are not block-scoped,


Where do primitives and objects stored in JS(refferencial confusion when we copy a value of an object to another object and change its property)
There is a source of confusion in this examples`
primitives ((7) Number, String, Boolean, Undefined, Null, Symbol, BigInt ) also called primitive types
let age =30
let  oldAge = age
age=31
if we log->age=31 oldAge=30 As we expected

but in case of objects (everything else besides primitives-> Object Literal, Array, Function, Data…	) also called reference types
const me={
name:”John”,
Age:30}

const otherMe=me;
otherMe.age=31;
log-> me AND otherMe are with same age=31 prop value->{name:”John”,
age:31} why?

-all our primitives are stored in call stack/in corresponding execution contexts
JS creates a so-called identifier with a var name(example age), then a piece of memory will be allocated with a certain address and value will be stored in memory at this address.
Identifier           Address         Value
age                     0001               30

so when we declare oldAge  it points to the same memory address, ;so the value will be 30, address value of primitives is immutable, can't be changed, 
so when we assign age to 31 ti will be kept in a new address
Identifier           Address         Value
oldAge               0001               30
age                     0002               31

-on the other hand in JS Engine where we have a ‘call stack’ and the ‘ the HEAP’-> where all our objects are stored.
when mew obj is created is also stored is heap in a specific address
in HEAP
          Address         Value
          D30F               {name:”John”, age:30}
‘me’ Identifier is not pointing directly to this address. instead it will point to a new piece of memory in the call stack
in call stack
Identifier           Address         Value
oldAge               0001               30
age                     0002               31
me                      0003               D30F
0003 address-> refers to memory address in HEAP/which is the reason we call objects reference types. It works this way, because objects can be too large to be stored in the stack. (HEAP is like unlimited memory pull)
When we create a new var otherMe, it will point to the same address in the call stack(0003),which refers to the D30F address in the Heap./does not create a new address in the HEAP/ 
When we are setting otherMe.age=31/or me.age=31, in D30F address the value of the age is changed from 30 to 31. We can manipulate objects, even if they are declared with const/by the way with let it work the same/.  so me.age also becomes 31. me @ otherMe are 2 different identifiers pointing to the same value.
Whenever we create a new obj by copying the old obj, we create a new identifier, which points to the reference to the same address in memory HEAP.

A way to change a property value in an object by not changing the original one
const otherMe = Object.assign({}, me);
but the new way of fixing the problem is using the spread const const otherMe ={...me}
Here a new object with a new address in the HEAP is created
this will only work for first level, and will not work when we have property, with value obj (all kind of obj, including arrays)
if const me{....., numbers:[1, 2]}
const otherMe = Object.assign({}, me);
otherMe.numbers.push(3), in case on me and otherMe the numbers array will me the same[1, 2, 3]
That is why Object.assign({}, me); method is called shallow copy method.
the number property value points to the same heap address in case for me and oterMe.
We need deep clone here, an external library, like lodash which has a deep clone tool.

Another example for other confusion.
const x={prop:”propname”}
const y={prop:”propname”}
console.log(x===y)-> false stored in diff places
____________________________________________________
If
 const x={prop:”propname”}
const y=x
console.log(x===y)->true-> refer to the same address in memory

JS basics
History
 -1995-JS invented by Brenden Eich in 10 days. called Mocha, had many fundamental features of modern js.
-1996-Mocha changes its name to Livescript, and then JavaScript-to attract developers, for marketing reasons. but has almost nothing to do with JAVA
Microsoft launches IE, copying JS from netscape, and calling it JScript
-1997 with the need to standardize the language, ECMA(independent organization) releases ECMAScript 1(ES1), first official standard for JS 
(Ecmascript is standard, js is language in practice)
-2009 release ES5 with a lot of great new features
-2015 ES6 release-> the biggest update ever!
after-> every year release
It is more correct to say release and not version, because JS has backward compatibility,(almost nothing is removed, instead new features added, updates), for websites to work forever. all the old features remain. in every release the projects don't crash, because old features work. That's why there a a lot of bugs, starting from the first release.(typeof null->object, var can be perceptive as a bug)
But if the browser is old, new features don't work, the browser doesn’t understand-> has no forward compatibility.
So how do we use modern js considering the problem mentioned above?
1 of all developers should use modern \Chrome during development, to ensure all the features work.
2. During production the problems arised. users can have old browsers.
The solution is to use Babel to transpile and polifil code(convert back to ES5-> to ensure browser compatibility for all users)ES5 fully supported in all browsers -> down to IE 9 from 2011. Babel also responsible for turning jsx code into react.create element, meaning turning jsx into HTML real elements.
Webpack(alternative is PARSEL) traverses the tree, goes to the source tree//all files/ and bundles a tree into a few files->when we type npm start/npm build-> this is for production/server-> webpack DevServer takes those files bundles, holds them in memory.
NOde allows to run JS outside the browser NPM/node package manager is a package manager for  node applications.
When changes are made in a  virtual dom, it creates a new version,  it is being compared with the old virtual Dom and if there are differences the actual dom is being updated.

What is JS?
JS is High-level, object-oriented, multi-paradigm programming language.
but this was a brief definition.
JS is High-level, prototype-based object-oriented, multi-paradigm programming language, interpreted or just-in-time compile, dynamic, single-threaded, garbage-collected prog language, with first-class-functions and a non-blocking event loop concurrency model.
About this definitions see below:
JavaScript (JS) is called a scripting language because it is primarily used for scripting tasks, which involve automating repetitive or routine tasks in a program or web page.
Scripting languages are interpreted languages, which means that the code is executed directly without the need for compilation.



Data structures in JS
In JavaScript, a data structure refers to a way of organizing and storing data so that it can be accessed and manipulated efficiently. There are several built-in data structures in JavaScript, such as arrays, objects, and sets and maps, weakmaps, weaksets.
Build-in data structures are arrays, objects, maps, sets… Custom data structures can be implemented using classes, constructors, and other language features.
Non build-in data structures include stack, queues, hashed tables, linked-lists.

Source of data
-internal/from the program itself/written in the source code
-From the UI // data input from the user
-external source//web api//fetched data
NO matter where the data comes from, we usually have collections of data, which should be stored in data structures. If we have a simple list, we are going to use an array or a set.If we have key-value pair-> obj or maps.
from web apis data usually comes in JSon format-> long string, which can easily converted into object. so we usually store this fetched data in objects, inside of objects id we have a data item with a special common description, f. e. cars, recipes, users, we’ll store them in an array of objects.

There are two types of constructors: built-in constructors such as Array and Object , which are available automatically in the execution environment at runtime; and custom constructors, which define properties and methods for your own type of object.
In JavaScript, constructors are special functions that are used to create and initialize objects. You can define custom constructors to create objects with custom properties and behaviors. Here's an example of a custom constructor in JavaScript:
// Define a custom constructor function called 'Person'
function Person(firstName, lastName, age) {
  this.firstName = firstName;
  this.lastName = lastName;
  this.age = age;
}

// Create an object using the 'Person' constructor
var person1 = new Person("John", "Doe", 30);

// Access the properties of the 'person1' object
console.log(person1.firstName); // Output: "John"
console.log(person1.lastName); // Output: "Doe"
console.log(person1.age); // Output: 30


Array
In JavaScript, an array is a data structure that stores a collection of values in a single variable. It is a type of object that consists of an ordered list of elements, each of which can be of any data type, including numbers, strings, objects, or even other arrays.
Arrays in JavaScript are declared using square brackets [] and can be initialized with values separated by commas. For example, the following code creates an array of three numbers:
Arrays in JavaScript are zero-indexed, which means that the first element of an array is assigned an index of 0,
indexOf VS includes arr methords
arr.indexOf(‘smth) returns the position where the item is (if there isn’t returns -1), 
but includes return true if there is an item or false if there isn’t.

only primitive types are immutable so we can’t define with const keyword and than change the value
but when we use constructors like arrays and objects const arr=[1, 2, 3, ], we can change item->   arr[1]=10, but we cant do arr=[1, 10,3] -> will get error typeError -> assignment to constant
Arrays are also objects, because they have their own methodist, build-in methods
Lracum: fill() method
let arr = [, , , ,]; or  let arr=new Array(4)
  arr.fill("whateverValue we want");

arr.some(el=>el.name===”sometname”)-> method returns true if the condition is true
arr.find(el=>el.name===”sometname”)-> returns item(in this case object). There is also arr.findIndex method which returns not the item, but the index
Arr.reduce -> reduce is a HOF which reduces an array of values to a single value by applying a callback function on each element of the array. It has 2 argos` 1 the callback function, 2` is optional, it indicates the initial value, if we dont 
It is use for
Getting the sum of an array elements`const sum=arr.reduce( (acc, el)=>acc+el, 0)-> here we can just skip the second arg,
 Finding the biggest number in an array` const maxValue=arr.reduce((acc, el)=>acc>el?acc:el)
Return unique array 
const uniqueArr = (arr) => {
        return arr.reduce((acc, el) => {
          return acc.includes(el) ? acc : [...acc, el];
        }, []);
      };

4.flattening an array
const nestedArray = [[1, 2], [3, 4], [5, 6]];
const flattenedArray = nestedArray.reduce((acc, curr) => acc.concat(curr), []);
5.conuting currencies
const fruits = ['apple', 'banana', 'orange', 'apple', 'orange', 'orange'];
const count = fruits.reduce((acc, curr) => {
  if (curr in acc) {
    acc[curr]++;
  } else {
    acc[curr] = 1;
  }
  return acc;
}, {});
// Output: { apple: 2, banana: 1, orange: 3 }

arr.sort((a,b)=>(a>b?1:-1))//for numbers as well as strings, alphabetical sort
const arr = [111, 22, 3, 45, 15, 6];
const sortedArray = arr.sort((a, b) => (a > b ? 1 : -1));// we could instead write (a, b)=>a-b // this will only work with numbers






More complex sort example->
const booksArr = [
        { title: "title 1", author: "john bDoe" },
        { title: "title 2", author: "john aDoe2" },
        { title: "title 3", author: "john nDoe3" },
      ];


      const sortedArray = booksArr.sort((book1, book2) => {
        const authorLastName1 = book1.author.split(" ")[1];
        const authorLastName2 = book2.author.split(" ")[1];
        return authorLastName1 > authorLastName2 ? 1 : -1;
      });





arr.join(‘’)-> to join all array elements ( not concat, concat in for 2 arrays), apposite to split method, returns string. We can decide how to concat items by .join(‘***”).Doesnt mutate prev arr.
newArr=arr.slice(2) if 1 parameter cuts first 2 returns rest, if 2, 3(second arg is also starts from beginnin), cuts first 2 and then starting from 4, returns 1 el in this case. Doesnt mutate prev arr. If (-2) cuts 2 last el, returns rest, if we just slice() without arg, than we will get the shallow copy of an array(like with spread operator) 
newArr=arr.splice(2) if 1 arg, returns first 2, if 2, 3(number of elements) returns 3 element starting from 3d element. (like a cake piece). Mutates prev arr, leaves the rest, in first case arr starting from 3rd element, in 2 case-> first 2 element leaves and the rest of the arr, except the 3 cut elements
arr.reverse() mutates original arr
Instead of arr[0]-> arr.at(0)->practical usecase to get the last element arr.at(-1) instead of arr[arr.length-1], works with strings also
Summarize:
Methods mutating original arr->
add to original:push,unshift
Remove from original: pop, shift, splice
other:fill, sort, reverce

Methods creating a new arr->
map, concat, filter, slice, flat, flatMap

For items->
find->returns item, findIndex, indexOf->returns index

If arr has->returns booleans
Includes, some(callback), every(callback)

A new string
Join

transform to a new value(any type)
Reduce

Loop
forEach

Objects
In JavaScript, an object is a data structure that stores a collection of key-value pairs. It is a type of reference data type, which means that it stores a reference to its location in memory rather than the actual value itself. The key is always a string, and the value can be of any data type, including numbers, strings, arrays, functions, or even other objects. Here's an example of an object with three properties:
 JavaScript, object properties can be defined with or without quotes, but there are some rules to follow.
If the property name is a valid identifier, which means it starts with a letter, underscore, or dollar sign, and contains only letters, numbers, underscores, or dollar signs, then you can define the property name without quotes.
However, if the property name is not a valid identifier, such as a name with spaces or special characters, then you need to define it with quotes. For example:
In JavaScript, there are two ways to access properties or methods of an object: using dot notation and using bracket notation.
You can also use quotes to define property names that are valid identifiers, but this is not required. For example, the following code is also valid:
 age: 30, is the same as “age”:30
in Objects we can put  functions as as a value to a key, and any functions attached to an object called method. but we cannot  put function declaration, we can only put function expression, wich produces a value vor a variable`
age:function(birthYear){return 2023-birtyear}
we see that the method is also a property, because it is attaches to an object with key-value pair.
The main difference between dot notation and bracket notation is that dot notation is used when you know the name of the property you want to access, while bracket notation is used when the property name is dynamic or when it contains spaces or special characters.
For example, if you want to access a property whose name is stored in a variable, you can use bracket notation:
const myObj = {
        name: "John",
        age: 30,
        job: "teacher",
      };
      const proptSelectJon = prompt("what property do you want to see");
      console.log(myObj[proptSelectJon]);
if we write myObj.proptSelection it returns undefined, because we don't have property called proptSelection, it is stored in a var, thats why we should get it by bracket notation
Another example of when to use bracket notation is when the property name contains spaces:


const person = {
  "first name": "John",
  "last name": "Doe",
};
console.log(person["first name"]); // "John"

 Array destructuring in Es6 feature, is a way of unpacking objects into separate variables, breaking a complex structure into smaller data structures like variables. We retrieve and store vars from an array in a variable.
destructuring inside destructuring for nested arrays->
const array = [1, 2, [3, 4]];
  const [one, , [, four]] = array;
  console.log(one, four);->1 4
destructuring arrays with default values
const array = [1, 2, 3]; 
const [one = 10, two = 10, three = 10] = [1, 2];
  console.log(one, two, three); -> if exist keeps value if not puts default-> 1 2 10

Object destructuring on the contrary to arrays the order of value does not matter and also we don't need to put , ,name.It is important to just write exact property name->const myObj = {
        "first name": "John",
        age: 30,
        job: "teacher",
      };
      const { age, job } = myObj; or if we need only age {age}=myOBj
same way if er have function which receives obj as a parameter, we can destructure it 
instead of myFunc=(parameters)=>{}
myFunc=({valuename 1, valuname2})=>{}
and also we can put default values as below

 const {age:myAge, job:myJob}= myObj;

destructuring objects with default values
 const {job=”defaultJob”, someproperty=[]-> empty array } = myObj;
 It is very useful when we get data, and we don't know if the property exists, so we can put a default value for it.
variables mutating with object values 
      let first_name = "previous name";
      let age = 29;
      const myObj = {
        first_name: "John",
        age: 30,
        job: "teacher",
      };
      ({ first_name, age } = myObj); -> we can’t put const before so ()
      console.log(first_name); -> John

Nested obj destructuring
   const myObj = {
        first_name: "John",
        age: 30,
        jobs: { first: "manager", second: "HR", third: "programmer" },
      };
      const {
        jobs: { first: myFirstJOb, second },
      } = myObj;
      console.log(myFirstJOb, second);->manager HR



Spread operator (...)
expand array into all elements, unpacks into one.
We use(...) to copy arr/obj, and spread properties, or pass multiple values into functions
  const arr = [3, 4, 5];
      const OldWayArray = [1, 2, arr[0], arr[1], arr[2]];
      const newWayArray = [1, 2, ...arr];


if we log arr->[3, 4, 5]
if we log …arr->3, 4, 5 -> unpacks

spread operator works not only for arrays, but for all iterables(arrays, strings, sets, and maps)
Some examples of iterable objects in JavaScript include arrays, strings, maps, and sets.spread operator for strings
  ( any object can be made iterable by implementing the "@@iterator" method) 
const me = "Armine";
      console.log([...me, " ", "A."]);
NOTE: In this case we are again creating an array , we can't just write 
 console.log(`${...me} A.`);
syntax error Unexpected token '...' 
passing into functions as separate arguments
The spread operator allows an array to be expanded into individual arguments when calling a function. Here's an example: when declaring function the number of parameters are mentioned
      function sum(a, b, c) {
        return a + b + c;
      }


      const values = [1, 2, 3];
      const result = sum(...values); 
     console.log(result); // Output: 6
// Using spread operator to pass values as separate arguments(1, 2, 3)


without …, passing just values`->sum(values)->the output will be->
1, 2, 3undefinedundefined->concat of parameter a will be arr, b and c undefined

objects

const me = { name: "John", age: 20, job: "HR" };
      const newMe = { ...me, eyeColor: "black" };
      console.log({ newMe });


Rest patterns(...), and rest parameters, 
-is the opposite of spread, looks the same, has the same syntax, collects to an array, after the last variable, while destructuring, packs into one//(spread-> unpack)
-spread in on right side of = operator, rest in on left side, while doing 
destructuring=>
-rest is where  variables, spread where values
1.use case:destructuring
  const arr = [1, 2, 3, 4, 5, 6, 7];
      const [a, b, ...others] = arr;
      console.log({ a }, { b }, { others });
      //otput-> 1, 2, [3, 4, 5, 6, 7]

same with objects, the rest elements will be collected into obj
const obj = { one: 1, two: 2, three: 3 };
      const { one, ...rest } = obj;
      console.log(first, rest);
      //output-> 1  {two: 2, three: 3}

2.use case: functions//opposite spread
for a function we want to use multiple parameters, but without specifying how many, every time can get different number of args
The rest operator allows a function to accept an indefinite number of arguments as an array. Here's an example:when declaring function the number of parameters are not known
  //collects into one array
      const myFunct = function (...args) {
        console.log(args);
//and outputs array
      };
      myFunct(1, 2, 3);
      myFunct(1, 2, 3, 4, 5, 6);
      myFunct(55, 66, 77);
      //output 3 arrays (3) [1, 2, 3]
      // tes(6> output) [1, 2, 3, 4, 5, 6]
      // tes(3) [55, 66, 77]
or
  const myFunct = function (firstEl, ...args) {
        console.log(firstEl);
        console.log(args);
      };
      myFunct(1, 2, 3);
output->1, [2, 4]
if     const myFunct = function (firstEl) {
        console.log(firstEl);
      };
output->1 only first element
rest with funct object parameters
      const myFunct = function ({ ...args }) {
        console.log(args);
      };
      myFunct({ one: 1, two: 2, three: 3 });
      myFunct({ one: 1, two: 2, three: 3, four: 4 });
      myFunct({ fiftyfive: 55, sixtysix: 66, seventySeven: 77 });
      //-< outputs 3 objects

In JavaScript, the expression “x in y” is used to check if an object y has a property x in its prototype chain
const person = {
  name: 'John',
  age: 30,
  city: 'New York'
};

console.log('name' in person); // Output: true
console.log('gender' in person); // Output: false
‘in’ operator can also be used with arrays in JavaScript. However, it works differently with arrays compared to objects. When used with arrays, the in operator checks if the given index is a valid index in the array.
const fruits = ['apple', 'banana', 'orange'];

console.log(0 in fruits); // Output: true
console.log(3 in fruits); // Output: false


Logical operators (&& || ??) 
for not only outputting boolean
(if( …||...or…&&... ){do something})

They can use ANY type, return ANY type, short-circuiting
OR operator short-circuiting returns first not falsy value, stops as soon as meets first true value
   console.log("" || false || "me") ->”me” here we have 3 operands, and first 2 will be skipped, because they are falsy
if all falsy returns the last one->console.log(null || false);->false

AND operator short-circuiting work opposite to or operator
console.log("me" && null);
-> returns first falsy value->null
console.log("" && false && "me") ->””
if all true values returns the last one->”me”&&”you”->”you”
that's why we use if something exists && otherthing
we can do something like this
2 > 1 && console.log(‘something’)
_________________________________________________________________
here we use to check whether all values are true or not
console.log(
        !(undefined && "me" && "1" && "me")
          ? "there is a falsy value"
          : "there is no falsy value"
      );

Nullish coalescing operator (??) works almost the same as or operator, but works with concept of Nullish values(null and undefined / it doesn't include ‘’ or 0), not falsy values
so if we have someNum=0; -> this will be returned, not skipped/same for empty string
logical assignment operators
 OR assignment operator  ||=
// if We want to assign a prop to an object if it doesn't exists
      const someObj = {
        prop1: "one prop",
        prop2: "two prop",
      };
      someObj.prop2 = someObj.prop2 || "Default prop";
instead write->
someObj.prop2 ||= "Default prop";
NULLISH assignment operator  ??=  to allow ‘’ or 0 values
const someObj = {
        prop1: 22,
        prop2: 0,
      };
      someObj.prop2 ??= "Default prop";   //keeps 0 for prop2
 AND assignment operator  &&=
// We want to reassign the value it it exists
      const someObj = {
        prop1: 22,
        prop2: 77,
      };
      someObj.prop2 &&= "new value";



ES6 new way of looping through arrays
for..of
      const arr = [1, 2, 3, 4, 5, 6, 7];
      for (const item of arr) console.log(item);
we can still use break and continue here
same as  
const arr = [1, 2, 3, 4, 5, 6, 7];
      arr.forEach((element) => {
        console.log(element);
      });
if we use 
 for (const item of arr.entries() ) console.log(item);
Or for(const [i, item] of arr.entries())
entries() method in for ..of loop, we’ll see  corresponding arrays for each item, with index as a first item[0, 1]and value as a second item (7 arrays [0, 1] [1, 2], [2, 3].....)
arr.forEach((ell)=>{})->takes callback as arg, wish can have 3 arg-> el, index, array
!note that order for item and index are different for this 2 methods
!node 1 fundamental difference, we cannot use ‘break’  and ‘continue’ in case of forEach



in case of objects, which has a prop with array value->
const obj = {
        numbers: [1, 2, 3, 4, 5, 6, 7],
        method(a, b) {
          return a + b;
        },
      };
      console.log(Object.entries(obj.numbers));
-> ['0', 1]
   ['1', 2]...
with OBJECTS
 const obj={
prop1:454545,
openingHours: {
          key1: "value1",
          key2: "value2",
          key3: "value3",
        }
}
returns array of arrays with key value pairs`
[
[‘key1’:’value1”], [‘key2:’value2”]...
]

ES6 made it easier to write object props, which value and key are the same like
const propName=”propName”
1.{..., propName, …}instead of {..., propName:propName, …}
and for methods`
2. {..., funcName(){}, …}instead of{..., funcName:function(){}, …}
3. compute props means every variable we have outside we can bring as prop(like instead of propName write `day-${3+3}`), also values can be computed, like can write 2+2-> will be calculated
ES2020 introduced optional chaining for checking if prop exists for nested objects obj.someProp?someOtherProp?.someNested ??(or ||) ‘not exists’
FOR OBJ METHODS
 const obj = {
        numbers: [1, 2, 3, 4, 5, 6, 7],
        method(a, b) {
          return a + b;
        },
      };                      //.for function args is necessary
      console.log(obj?.method?.(2, 3) ?? "This method does not exist");
optional chaining FOR Arrays
instead of writing(if (!users.length>1) console.log(users.[0].name)else{........})
console.log(users[0]?.name && ‘first user exists’)

for …of can be used with objects also 
Object.keys(obj) -> returns array of the the object’s keys
we can loop through for
for (const objKeyItem of Object.keys(obj)) {
        console.log({ objKeyItem });
      }
but when we need not keys but values?
for (const objValueItem of Object.values(obj)) {
        console.log(objValueItem);
      }
but when we need keys and values?
for obj property` 
    const obj = {
        numbers: [1, 2, 3, 4, 5, 6, 7],
        method(a, b) {
          return a + b;
        },
        openingHours: {
          key1: "value1",
          key2: "value2",
          key3: "value3",
        },
      };
      const entries = Object.entries(obj.openingHours);
->array of key-value pairs arrays [[key1:value1],[], []]
      console.log(entries);
      for (const [key, value] of entries) {
        console.log(key, value);
      }
->key1 value1
key2 value2…..


Data structures continue
in ES6 2 more data structures introduced SETS MAPS
These data structures exist in other languages, now in JS also SET is a collection of unique values-> no duplicates, can hold mixed data types.
To create-> new Set(here is iterable, the most common iterable is array)
const mySet = new Set(["value1, "value1",, "value2", "value3", "value3"]);
If we log, we’ll see that all the duplicate values have been removed
Set(3) {'value1', 'value2', 'value3'}, looks like an array but without [], but it is different. It is also iterable
const mySet = new Set("Armine");
      console.log(mySet);
Set(6) {'A', 'r', 'm', 'i', 'n', ‘e’}
-has a size property->mySet.size-> 6
-add->mySet.add("newVal")
-has->mySet.add("newVal")->true
-delete item-> mySet.delete("value3");
-clear the set->mySet.clear()-> returns empty set` {}
-loop through the set->
for (const item of mySet) {
        console.log(item);
      }

//with array there is no this simple method(we use filter or splice…)
-to retrieve item we can’t do it by mySet[index], there are no indexes, if we need to retrieve we should use an array, here is no need, all are unique, and set has .has() method to check if the value exists.
It is a very common use case for removing items from arrays
      //create a new unique array
      const myArr = ["value1", "value2", "value3", "value3"];
      const myNewUniqueArr = [...new Set(myArr)];
      console.log(myNewUniqueArr);
//by [...set] we unpack the values of the set into the array
//to know how many unique items are there in the arr, use .size
Another interesting way to get rid of repeating items, is to use reduce() method

MAPS-are more useful than sets- is used to map values into keys.
They like objects are also in key-value pairs, but the main difference is that maps can have keys not only string type-like objects, but other types like arrays, etc…
-have set method, witch can be chained as well
//create a new map
const myMap = new Map();
//fill a map with set method
myMap.set(1, "something");
myMap.set("bla bla", [1, 2, 3]).set(true, "blbla");

Map(3) {1 => 'something', 'bla bla' => Array(3), true => 'blbla'}
-have a .get() method to get the values
console.log(myMap.get(true));-> blbla
console.log(myMap.get("bla bla"));->[1, 2, 3]
An interesting use case for maps
myMap.set("open", 8).set("close", 16).set(true:”We are opened”);
      const time = 21;
console.log(
myMap.get(time > myMap.get("open") && time < myMap.get("closed"))
      );->’we are opened”
-.has() method to check if the property exists.
-delete()  //myMap.delete(‘keyName’)-size() //shows the length
-clear() the map->myMap.clear()-> returns empty map` {}
-keys()   ->const someMapIterator ={'question', 1, 2, 3, 'correct', …}, if we spread it into an array//[...someKeyIterator ]->array of keys
-values()   ->const someValueIterator ={‘C’, ‘JS’, 2 …}-> [...] array of values
// update the value of the key
myMap.set('key1', 'value1');
myMap.set('key1', 'new value');
We just have a little confusion while trying to get values when our keys are arrays of objects, because, they store in the HEAP and while trying to get the value, the same arr [1, 2] points to a different memory address
 myMap.set([1, 2], "something");
console.log(myMap.get([1, 2]));->undefined
the solution is 
 const keyArray = [1, 2];
 myMap.set(keyArray, "something");
console.log(myMap.get(keyArray));->”something
as keys we can use objects, dom keys(which are special type of objects)
 myMap.set(document.querySelector(h1), "something");
 it will even highlight if we hover over this object property
the second way to populate maps
Besides creating a new map and populating it with set method, we can populate it by immediately passing an array of arrays
      const myMap = new Map([
        ["question", "what is the best prog lang?"],
        [1, "C"],
        [2, "JS"],
        [3, "Kotlin"],
        ["correct", 3],
        [true, "Correct answer"],
        [false, "try again"],
      ]); ///array of arrays


//loop
for (const [key, value] of myMap) {
        console.log(key, value);
      }
We get the same array of arrays when trying Object.entries(myObj)
so there is an easy way to convert obj into map
const myMap = new Map(Object.entries(myObj)) 
convert map to an array
const myArray = [...myMap];
   console.log(myArray);



When and what data structure to use
arr & sets when we deal with a simple list and don't have description(keys). 

Arrays VS sets
Arrays-> 
1.when we want to have an ordered list, 
2.which can contain duplicates, 
3.when we need to manipulate the data.
Sets-> 
1.when we need to have a unique list, 
2.when high-performance is really important(searching and deleting an item is much faster than in an array), 
3.use set, when duplicated items need to be removed from an array

Objects VS maps
Objects-> 
1.More traditional key-value store
2.Easier to access prop with . or []
3.Need to include methods/functions
4.working with JSON easy, easily converted back and forth
Maps-> 
1.Better performance, easy to iterate, 
2.Keys can have ANY data type 
3.easy to compute(count) size

Another type of data structure is A binary tree is a common data structure in computer science and programming that consists of a collection of nodes organized in a hierarchical structure, where each node has at most two child nodes. 
Another type of data structure isA linked list is like a chain of connected nodes, where each node contains a value and a reference (or a "link") to the next node in the list. Think of it like a train, where each carriage (node) contains passengers (value) and is connected to the next carriage (next node) in the sequence.

STRINGS
In JavaScript, a string is a sequence of characters enclosed within single quotes (') or double quotes (").
In JavaScript, a string can be considered a basic data type, rather than a data structure.A string itself may not be considered a data structure in JavaScript, it can be used as a building block within larger and more complex data structures.
A string can contain letters, numbers, symbols, and spaces. It can also be an empty string, which contains no characters.To access a character we use stringname[positionNumber]
Strings in JavaScript are immutable//coz they are primitives, which means that once a string is created, its value cannot be changed. However, it is possible to create a new string that is derived from the original string using string methods such as slice(), substring(), replace(), concat(), and others.
const myString = "Armine";
//myString.slice(1, 2); than console.log(myString)-> will output the original string “Armine”->r
const newSt = myString.slice(4);->ne
const newSt = myString.slice(1);-> all except first letter ->rmine
//if one arg-> starting from start how many characters are gone ->ne
 const newSt = myString.slice(3, 5);->in
const newSt = myString.slice(-5, -3);->rm
const newSt = myString.slice(4, -1);
//last character
instead of
const newSt = myString.slice(myString.length - 1, myString.length);
const newSt = myString.slice(-1);->e
 console.log(newSt);
Strings in JavaScript can be concatenated using the + operator, which joins two or more strings together. 
built-in string methods indexOf(), charAt(), split(), toUpperCase(), toLowerCase(), length(), trim(),  and many others(there is no splice method with strings, only with arrays)
Strings are primitives, why should they have methods?
whenever a string call a method, JS behind the scenes converts the string into an object.// this process is called boxing-
const myString = new String("Armine");
if ve log it->
String {'Armine'}
0: "A"
1: "r"
2: "m"
3: "i"
4: "n"
5: "e"
length: 6
it is more like an object, which has all the methods in its prototype
and if we check   its type it will be obj
after the method is done it will change back its type. even if we first declared the string by new String() method

replace method in strings
 const newSt = myString.replace("$", "@"); 
//use replaceAll() if we expect to have more than 1 character/word/regex
myString.replaceAll(/a/g, "0");
it can be chained .replace(“hello”, “bye”)

-3 string methods that return booleans(includes(‘smth’), startsWith(‘smth’), endsWith(‘smth’))

-padding method
const myString = "Armine";
const newSt = myString.padStart(25, ".");//”  “
…………………………Armine-> altogether 25 characters
myString.padStart(25, ".").padEnd(35, "$");-> the padEnd val should be more than padStart, coz 35 is altogether characters length 
if we don't write the second arg, we’ll get empty spaces by default.
...................Armine$$$$$$$$$$
a good use case when we want to cover first(last) digits/master cart, phone.., 
 const showOnlyLastNumbers = (number) => {
        const str = String(number);
        const last = str.slice(-4);
        return last.padStart(str.length, "*");
      };
      console.log(showOnlyLastNumbers(1234567));->***4567

-repeat method
const str = "Departure is delayed... ";
      console.log(str.repeat(5));


FUNCTIONS

In JavaScript, a function is a reusable block of code that performs a specific task or calculates a value. Functions allow you to break up your code into smaller, more manageable pieces, and can be called and executed multiple times with different arguments.

FUNCTION TYPES
1 named functions ->function someName(){}
2.anonymous functions ->const funcName =function(){} or arr` const functName=()={}
3.arrow functions
4.immedeately invoked function expressions (IIFE)syntax->(function{})()->if we want to execute only once
5.Higher-order functions:take one or more functions as args and/or return funcs as a result

In JavaScript, a regular function is a function that is defined using the function keyword. Regular functions can take zero or more arguments and can return a value using the return keyword.
In JavaScript, all functions that are defined using the function keyword are regular functions, including methods and constructors. Arrow functions, on the other hand, are a different type of function that was introduced in ES6.
In JavaScript, a function is a type of object, and like any object in JavaScript, it can be assigned to a variable. Therefore, a function can be treated as a variable in JavaScript, but it is not necessarily always a variable.

In JavaScript, there are two ways to define functions: function declarations and function expressions.
1function declarations(A function declaration is a way of defining a function with the function keyword, followed by the function name,)  ->function someName(){}
we can call before they defined, because they are hosted
2function expressions (A function expression is a way of defining a function by assigning it to a variable. It can be defined using the function keyword or the new arrow function syntax) ->function someName(){}. this is actually an expression, because in returns value.
if we call before  it is defined, we’ll get an error
-> cannot call before initialization



Setting default args 
funct(value1=defaultVal1, value2=defaultvalue2)
we even can make args dependable on each other, instead of value=defaultvalue2, we can write-> value2=defaultVal1+2
if we have func with args with default values, and don't want to pass 1 or 2 arg, we can skip by writing them undefined and they’ll get their default values.
 const func = (val1 = 1, val2 = 2, val3 = 3) => {
      };
 func(5, undefined, 333);

In functions also when we pass the arg, and is arg has reference type, and if we for some reason try to mutate the values, the initial value also will be changed(see explanations of reference data types, that refer to the same address in the HEAP)
      const flightInitial = "AD111";
      const johnInitial = {
        name: "John Smith",
        passport: "123123123123",
      };
      const checkIn = (flName, person) => {
        flName = "ppppp";
        person.name = "Mr." + person.name;
      };
checkIn(flightInitial, johnInitial);-> !!! 
If we log outside the checking function johnInitial.name should be Mr…
John Smith

Why JS has first class functions- ALL functions in Js are first-class-functions, are just another type of objects, that's why functions are treated as simple vars, and we can 
1.store them in vars, and properties, 
2.pass functions as argos(event listeners, other callbacks), 
3.return functions from another functions, 
4.They can be stored in data structures like arrays or objects

In JavaScript, methods are essentially functions that are attached to objects as properties.
functions being first-class, make it possible to have higher order functions
hof
-Are functions that either have functions as args or return a new func, or both.
For example,addEventListener, forEach() are  hofs.
callBack functions help us create abstractions(hiding details, to think at a higher/abstract level). For example we could write the functionality of the callback function inside the hof, but we don't care how the callback func works, so we abstract it away into other functions. Basically hof works/operates  in a higher level, leaves a low level details to low level functions.
   const greet = (greeting) => {
        return (name) => {
          console.log(`${greeting} ${name}`);
        };
      };
      const HeyGreeter = greet("Hey");
      HeyGreeter("Sam");  // the returns function’ parameter is passed 
      HeyGreeter("Micael");//after creating a new variable of HOF, and passing arg to it 
-> Hey Sam
-> Hey Micael
Without storing the HoF function into a var and calling the var() function the output will not be shown.

Binding this to a method of an object, when obj call a method which is declared outside, and obj has not the method in itself at first
const lusthanza = {
        airlane: "Lufthanza",
        code: "LU",
        bookings: [],
        book(fligthName, passengerName) {
          console.log(
            `${passengerName} booked a seat on ${this.airlane}, flight is: ${this.code} ${fligthName}`
          );
          this.bookings.push({
            fligth: ` ${this.code} ${fligthName}`,
            passengerName,
          });
        },
      };
      const euroWings = {
        airlane: "Eurowings",
        code: "EW",
        bookings: [],
      };
      lusthanza.book(364, "John Smith");
      lusthanza.book(884, "Tom Black");


      //in order not to copy and paste the book function for EUROWINGS, we save it in external variable, but this becomes undefined(in strict mode this is a undefined
      //we should point explisitly what the this keyword poits at(3 methods-> call, apply, bind)
 const book = lusthanza.book;
      book.call(euroWings, 5959, "sara amith");
      book.call(euroWings, 555, "sara 55amith");


    Old way->  book.apply(euroWings, [555, "sara 55amith"]);-> difference is args i
n an array
      //this works without having book method in euroWings objunction becomes undefined)
     
      /// book(233, "Johannah");-> will return error, cannot read a prop/airline/ of 
//we dont use apply method anymore, instead we use call with spread operator
const flightArr = [555, "sara 55amith"];
      book.call(euroWings, ...flightArr);



Bind method is the most useful method!!!
//bind method has only 1 arg, pointing to the obj
      const bookEv = book.bind(euroWings);
      const flightArr = [555, "sara 55amith"];
      bookEv(...flightArr);// or bookEv(555, "sara 55amith")

 const bookLuft = book.bind(lusthanza); //bookLuft(...) -> for each aircompany
We can make even further binding. Binding with 1 same parameter, can only pass last parameter ->
const bookEv555 = bookEv.bind(euroWings, 555);
      bookEv555("newName");
      bookEv555("newName2");
-> bookings array(3) of 3 same flight number and 3 passenger names objects

Binding objects with eventlisteners
lusthanza.planes = 300;
      lusthanza.buyPlane = function () {
        console.log(this.planes);
      };
      lusthanza.buyPlane();-> will log 300//we called this inside a func, but it is called by the obj that's why it is working
WE have a button element
<button class="buy">Buy a plane</button>
WE want to attach an event listener to the button element , by clicking the button add the number of planes
document
        .querySelector(".buy")
        .addEventListener("click", lusthanza.buyPlane);
By clicking the button we’ll get a NaN coz this in buyPlane method points to the button element, which calls the buyPlane.->
.addEventListener("click", lusthanza.buyPlane.bind(lusthanza));

Partial application cases with bind method, when we dont have to this, we only want to bind to a function with a stable one arg
 //example we have a country with a stable rate
      const argentinaRate = addTax.bind(null, 0.25);->null for this 
Here we dont want to bind to this, and 0.25 refers to only the first arg
      console.log(argentinaRate(100));->125
      console.log(argentinaRate(200));->250
Here is a solution without bind method to keep on arg stable
const bindValue = value => rate => addTax(rate, value);

const bindValueTo100 = bindValue(100); // bind value to 100

const result = bindValueTo100(0.2); // bind rate to 0.2

console.log(result); // Output: 120
Or just 
const addTax = (arg1 = 100, arg2 = 400) => arg1 + arg2;
      console.log(addTax(undefined, 66));-> 166
 console.log(addTax(500));-> 900


here->


What is JS, HOW JS WORKS?
JS is High-level, object-oriented, multi-paradigm programming language.
but this was a brief definition.
JS is High-level, prototype-based object-oriented, multi-paradigm programming lang, interpreted or just-in-time compile, dynamic, single-threaded, garbage-collected prog language, with first-class-functions and a non-blocking event loop concurrency model.
High-level-
every program that runs on a computer needs some hardware such as memory & CPU(Central Processing Unit is a core component of a computer system that performs most of the processing tasks in a computer.)
There are low level languages such as C, where we manually need to manage this resources, for example asking the comp for memory to create a variable, with high level language we don’t need to manage these resources at all, they have so-called abstractions that take all this work, which makes language easier to learn and use, but the downside is that this languages will never be as fast or optimized as C. One powerful tool which takes  memory management from us is garbage collection.
garbage collection-
is an algorithm inside JS engine automatically removes all unused objects from memory, not to clog it up with unnecessary stuff, 
interpreted or just-in-time compiled-
computer processors only understand 0s and 1s.(machine code) which is not practical to write, that's why we write human readable code which is an abstraction over machine code, which needs to eventually be translated to machine code(this step is called compiling or interpreting). In the case of JS this process is done inside the JS engine. 
One of the reasons why JS is so popular, is that Js is
multi-paradigm language
paradigm is an approach and mindset of structuring code, which will direct your coding style and technique.
there are 3 popular paradigms
1.procedural programming-> organizing the code in a linear way, with some functions in between
2.object-oriented(oop)
3.functional programming(FP)
many languages have coding organization which uses only one of the paradigms mentioned above.
In case of JS we can use whatever paradigm we want we can use, so it is very flexible, versatile
(paradigms can be classified as imperative or declarative)
OOP JS is prototype-based
everything in JS is an object, except primitives.
Why can we create an array and then use the push method? It is because of prototypical inheritance. we create an array from array blueprint(նախագիծ) which called prototype, and has its methods, so when we create an array it inherited its methods from prototype
language with first class functions-
means functions are treated as variables, so we can pass func to other functions and even return functions from functions. It allows us to use a lot of powerful techniques and even write code in FP way (functional programming).
for example (.addEventListener(‘click”, someFunc))->pass func to a func as a regular variable. not all languages that have first-class functions
dynamic-
this means dynamically typed language
we don't need to assign data types to variables, they only become known when the JS engine executes code. We can even assign variables and the type will be changed if the new value has a different type. This is not true for most programming languages. It has its downsides. with not having strong typed variables, this can lead to getting more bugs. but with using typescript this issue is solved.
single-threaded(THREAD IS A SET OF INSTRUCTIONS handled by comp CPU, is a process when code is executed by a machine)-
concurrency(համաժամանակություն) model is that how JS engine handles a multiple tasks happening at the same time. JS itself is single threaded, so it can only do one thing at a time. We need something that can handle multitasking.
What if we have a task which can be very time consuming. for example getting data from the server. that will block the single thread. execution of the code will be stopped. That's why we need a non-blocking behavior, which can be achieved by the event loop. This takes long execution demanding tasks in the background and after puts them back in the main thread.
 

What is JS engine?
-> a program that executes JS code. Every browser has its own engine, but the most popular google’s v8, it powers google chrome and also node(outside any browser, helps JS run on server side). Other browsers have their own engines.
every JS engine has call stack(where all code is executed using execution context) and heap(unstructured memory pull, stored all the objects our app needs)

difference between compilation and interpretation
when a piece of code enters JS engine the first step is to parse the code, it is parsed into abstract syntax tree (AST), then generated AST enters the compilation step.
each code should be compiled to machine code to be executed. 
how the code is compiled?
2ays`
1.in compilation all code translated into machine code->  code is converted into machine code at once and written to a binary(portable) file that can be executed by a computer(1st step compilation, 2nd step execution)
2.in interpretation there is an interpreter which runs through the code and executes it line by line and interpreted at the same time. run and execute at the same time. The code is also compiled into machine code but right before execution. The problem with interpreted languages is that the code is much slower. Now with modern applications low performance is no longer acceptable. JS is no longer considered an interpreted language. Modern JS engine uses a mix between compilation and interpretation.
3. JS-> Just-in-time (JIT) compilation (mix between compilation and interpretation)->entire code is converted into machine code and at once executed(without writing it into portable file). this is faster then running code line by line
Execution happens in the call stack.
After execution the code is optimized and re-entered the compilation stage . this cycle can  happen multiple times (compilation->  execution(this happens in Call Stack)-> optimization(First the created machine code is very unoptimized, this happens in background, without stopping execution)-> compilation->)-> this cycle happens in a special thread we don’t have access.

we can imagine JS runtime as a big box. js engine works during js runtime. in order to execute code the engine is not enough, web api-s are also involved. There are also parts of js runtime.
Runtime also includes a so-called callback queue. data structure that contains all the callback functions. After the call stack is empty the event loop puts callback functions inside call stack, providing a non-blocking concurrency model.
In case of node js, when we don't  have a browser(the runtime environment is outside of the browser), we don't have web api-s. Instead we have c++ bindings and thread pool.
So after compilation, in execution step a global execution context is created (this is a top-level code without functions)
 execution context- is an environment  in which a piece of Js is executed, it stores all the necessary information for some code to be executed. Js always run inside the execution context. This is one global execution context for top-level code.
when top level code is executed functions start to execute as well. For each function execution context with all the necessary info for this particular function, is created. (the same is also for methods which are simply functions attached to objects). all this executions make the call stack. when all functions are executing the call stack is waiting for the callback functions to arrive. These functions are provided by the event loop.

execution context consists of 
1.variable environment. (let const var, functions, arguments object(all args that are passed into functions of corresponding execution context) )
arguments object/this keyword
regular functions get access to args obj(all except arr functions), as will as this keyword(which is undefined in strict mode and window in default or sloppy mode)
if we log it-> 
const addNum=function(a,b){
console.log(arguments)
return a+b
}
addNum(2, 5)
in console we will see
array [2,5]
we can also call the func with more than 2 args/not in typescript/ and they will be in arguments object as well
In case of arr funct we’ll see an error arguments is not defined
2. scope chain ->consists of variables located outside the current function, which this function can have access to.
3.this keyword (in case of arrow functions arguments object and this keyword is missing, instead they can use arg obj and this from their closest parent REGULAR function (all with function keyword including methods))
Example lracum:
     const myObj = {
        role: "user",
        myFunc: () => {
          console.log(this.role);
        },
      };-> undefiuned, if we log(this)-> windows



     const myObj = {
        role: "user",
        myFunc(){
          console.log(this.role);
        },
      };-> “user”, if we log(this)->{role:.....,...}






event loop


In JavaScript, the event loop is a mechanism that manages the order in which tasks are executed in the program. It is responsible for scheduling and executing asynchronous code and processing user interactions
main concept of JS is doing only one thing at a time, unlike other languages, that means JS is a single threaded.
The event loop in JavaScript is a constantly running process that manages the execution of the code in the following structure:
The main thread starts running the synchronous code and creates the call stack (order if which functions are called).
If there is any asynchronous code such as callbacks(including callback functions from dom event listeners( but not all callbacks, is it is not async, and is ordinary arg that passed as arg and should be executed at once)), promises, or timers, it is registered with the relevant APIs (such as setTimeout or Promise).
JavaScript in the browser environment provides a built-in API called the Promise API 
fetch('https://jsonplaceholder.typicode.com/posts')
  .then(response => response.json())
  .then(data => console.log(data))
  .catch(error => console.error(error));
In case of eventLIsteners callbacks->when you register a callback function as an event listener using a web API like addEventListener in JavaScript, the callback function is being registered by the DOM (Document Object Model) web API .Once the event occurs, such as a button being clicked or data being loaded, the registered callback function is then added to the event queue,
Once the asynchronous code is registered, it is removed from the call stack and added to the event(or callback) queue.(koxqi web api-um en grvum- amenaskzbum nkarov, voch te call stack-um)(the web API is given from the browser)
The event loop constantly monitors the call stack and the event queue. If the call stack is empty, the event loop dequeues the first event from the event queue and pushes it to the call stack( first in first out skzbunqov, chhashvac macro and microtask).
The code in the call stack is executed, and once it is completed, it is removed from the call stack.
If there is any new asynchronous code, it is registered with the relevant APIs and added to the event queue.
The event loop continues to monitor the call stack and the event queue, and the process continues indefinitely until there are no more events in the queue.
This structure allows JavaScript to handle multiple tasks simultaneously, making it possible to build efficient and responsive applications that can handle complex workflows and user interactions.
In JavaScript, an execution context refers to the environment in which a function is executed. It consists of the function's scope, the value of the "this" keyword, and any variables or parameters that are in the function's lexical scope.


if we have 2 func in the code, we have one global execution context(this glob ex context is created for top level code and it will be first put in the call stack and started to execute) and 2 local each for each function. Inside global context are all vars and functions values, but functions returned values becoming defined when code is executing.
in global execution context we have x=first()-> so this func should be called, thats why execution context for this function is creating and put in call stack.



inside first funct, second is called thats why new execution context is created for second and put in the call stack on top. than after exec it second moves out from call stack, than first() moves out. And only Global stays, it like this till browser closes the global ex context is also popped  out of the call stack.

what are scope and scope chain?
Scoping controls how vars are organized and accessed.
Scope is a space or environment in which a certain var is declared. there is global, function and block scope. 
Scope of a var:Region of our code, where a certain var can be accessed. Var doesn’t live outside its scope.
global scope: Outside of any function or block, var declared in global scope are accessible everywhere.
function scope:also called local scope. declared and accessible only inside the function
block scope:(starting ES6 blocks also create scops). if statement, for loop ..{}, only applied for variables declared by let and const.
starting from es6 functions are also block scoped, can’t call outside the block{}, in strict mode.
If a var is accessible inside a concrete function, for example from the global scope, it will be accessible for its child function(which is declared inside that function(scope chain)). if the engine can’t find the var in a parent func it looks up (this is called variable lookup) in a parent of a parent func. Every scope has access to all the vars from outer scopes. 
THis called a scope chain, mechanism to determine how variables are accessed and resolved in a nested hierarchy of function scopes.. variable lookUP in scope chain-> this works only one var. from inside to outside.scope chain is essentially a linked list of lexical environments,

variable enviroment:
Hoisting : in JavaScript is a mechanism where variables and functions are moved to the top of their respective scopes during the compilation phase before the code is executed.
Hoisting makes some types and vars accessible/usable in the code before they are actually declared.
before execution code is being scanned and for each variable a new property is created in the variable environment object.
hoisting does not work the same for all types.
function declarations are hoisted, . initial value is actual function->we can use them before they are actually declared, and if we use strinct mode, they are block scoped, it not-> funct scope
var variables are hoisted. but unlike funct declaration if we try to access it before declaration it will give reference error->undefined(but not error!!!!) and is common source for bugs-> and is function scoped
(variables declared with var keyword and if declared outside a funct create properties of the global obj/window)
let const variables->not hoisted,initial value-> if we try to access before its declaration we will get error(they are in temporal dead zone TDZ->from the starting block scope till declaration, can be only used starting from the line where it is declared and within the block scope-> will get reference error, cant access before initialization, if we try to access a variable what is never been declared will get different error->reference error, var is not declared), block scoped.
function expressions and arrow funcs->behave exactly like variables, behave like var variable, if declared with var and like let or const like let or const variables.

THIS keyword
is a special variable that is created for every execution context.
for every function its execution context is created and this points(takes the value) to its owner.
It is not static, it's created when a function is actually called, and depends on how the function is called.
1.function with function keyword
const someFunc=function(){
console.log(this)  → in strict mode this is undefined  //strict mode
rule:inside a regular function call, this keyword in undefined
, and window obj-> without strict mode
}
2.if a function call is a method of an object(attached to an object)-> this takes value of that obj. const person={name:”John”,  year:1981, calcAge:function(){return 2023-this.age}. this points to the object not because it is written inside the obj, but because the obj is calling that funct, (person.calcAge())as in case of event listeners,
if we write another otherPerson.calcAge=person.calckAge, and call otherPerson.calcAge, this will point to otherPerson obj, this is dinamic.
In another case if we create a new obj and assign the funct to it`
const x=person.calcAge
x()-> we’ll get error in strict mode cant read property of age of undefined (see below)-> there is no owner of the function, that's why this is undefined, and it throws error ‘cannot read property of undefined
4.arrow function doesn't have own this, it takes from its surrounding function/environment(lexical this)/it inherited this from its parent scope-> is points to window obj even in strict mode
if we have an obj, and one of the methods is called by function keyword, this will work in it, as above, but if we have property with an arrow function, this will be undefined, because global obj has no property year to read its value.
but if we wrote above//outside the obj-> var year=1981, it will create the property for window obj and the arr function will work, returning calculated value for 1981.
5. if it is called as an event listener, this keyword refers to the DOM element that the event listener is attached to.

6. calling a Function inside a method, . Inside our example calcAge: function().... we try to call another function somefunc=function(){ console.log(this) } and immediately call it inside somefunc()`  -> this will throw error cannot read property year(this is undefined), there is no object calling this function, rule:inside a regular function call, this keyword in undefined.
Some consider this behavior a bug, but it is how this behaves. The solution is to assign just above the function const self=this. not self will be accessible inside the func. but the better solution is to use arrow function here, which will take ‘this’ environmental/lexical this from parent scope. arr func has no its ‘this’.
what to REMEMBER: this never points to the function itself, it points to an obj calling the function
rule:inside a regular function call, this keyword in undefined(in strict mode, and points to window object without strict mode). In case of arrow functions always window, obj. (Or surrounding lexical envirement)
 
statements VS expressions in js
expression returns a value-> 4+6, 100, ternary operator…
statement is a piece of code that usually ends with semicolon; translates action.
expression can be put in a template literal `${expression}`, in contrast to statement.

Strict mode
always on 1t line, otherwise it will not work, makes it easier to write a secure, avoid accidental errors, and clean code, otherwise js can fail silently. only comments allowed before and js will plainly ignore them.
 "use strict";
1 example, let some var equals false, assign in with misspelling, the \JS without strict mode will consider it as a new variable, and code will run wrong, but with strict mode without let )declaration) it will return a reference error (the variable is not defined(.
 // "use strict";
      let kim = 1;
      kih = 2;
      console.log(kih); -> without strinct will log 2, with strict->error

2 example, when using example let class, let private….. returns uncaught syntax error, reserved word,



ASYNCRONOUS JS
Asynchronous JavaScript refers to the programming paradigm where code execution can continue without waiting for certain time-consuming operations.
Async JS used, where applications need to interact with servers and databases that may take time to respond. By using asynchronous programming, web applications can continue to respond to user input and update the UI while waiting for a response from the server.
In JavaScript, asynchronous programming can be achieved through various mechanisms, including callbacks, promises, and async/await syntax. These mechanisms allow developers to write code that can handle time-consuming operations in a non-blocking way, improving the overall performance and responsiveness of their applications.

what is I/O operations in JS?
In JavaScript, I/O (input/output) operations refer to any operation that involves reading from or writing to an external source, such as a file system, a network, a database, or a user interface.
JavaScript has both synchronous and asynchronous I/O operations.
Some examples of I/O operations in JavaScript include:
Reading data from a file (can be sync and async->
 	const fs = require('fs');
const data = fs.readFileSync('file.txt', 'utf8');

File reading with the readFileSync method is synchronous, meaning that it blocks the execution of code until the file is fully read. but just readFile(), which is recommended way-> is async->
const fs = require('fs');
fs.readFile('file.txt', 'utf8', (err, data) => {
  if (err) throw err;
  console.log(data);
}); )
Writing data to a file on disk
Making a network request to an API to fetch data
Sending data to a server using HTTP POST(we can do async and sync requests using XMLHttpRequest  object but it's not possible to make a synchronous API call with fetch, with axios we can call syncronously: see below)
Reading and writing data to a database
Interacting with the user interface, such as reading user input from a form or updating the DOM with new content.
I/O operations in JavaScript can be time-consuming and may cause the program to block while waiting for the operation to complete. To avoid blocking the program and to ensure that it can continue to respond to user input and update the UI, developers often use asynchronous programming techniques, such as callbacks, promises, or async/await syntax, to handle I/O operations in a non-blocking way.

it is possible(but not recommended) to make synchronous API calls using Axios. Axios provides a config option called synchronous, which can be set to true to make a synchronous request.
Here's an example of how you can make a synchronous API call using Axios:
axios({ method: 'get', url: 'https://api.example.com/data', synchronous: true }) .then(response => { console.log(response.data); }) .catch(error => { console.error(error); });
In this example, we pass an object with the request configuration as the first argument to the axios function. We set the method to 'get' and the url to the API endpoint we want to call. We also set the synchronous option to true.
We then chain a then method onto the Promise returned by axios, which logs the response data to the console if the request was successful.
To make a synchronous network API call, you can use the XMLHttpRequest (XHR) object with its open() and send() methods. However, this approach is not recommended because it can cause your application to become unresponsive while the API call is being made. 
const xhr = new XMLHttpRequest();
xhr.open('GET', 'https://example.com/api', false);
xhr.send();

if (xhr.status === 200) {
  console.log(xhr.responseText);
}
fetch() method is async
The fact that fetch() returns a Promise means that the code execution does not block while the API call is being made. 
2ways to make fetch() async call
1.
fetch('https://jsonplaceholder.typicode.com/todos/1')
  .then(response => response.json())
  .then(data => console.log(data))
  .catch(error => console.error(error));
2.
async function getData() {
  try {
    const response = await fetch('https://jsonplaceholder.typicode.com/todos/1');
    const data = await response.json();
    console.log(data);
  } catch (error) {
    console.error(error);
  }
}
Fetch method has one mandatory arg` URL
Apart from the URL argument, you can also provide an optional second argument, which is an object containing configuration options for the request. This object can include properties such as method, headers, body, mode, credentials, cache, redirect, referrer, integrity, keepalive, and others, that allow you to customize the behavior of the request.
Example POSTING data.
const data={...}

const url=”,,,,”
const options = {
  method: "GET", // HTTP method (default is GET)
  headers: {
    "Content-Type": "application/json"
  }, // Custom headers
  mode: "cors", // CORS mode
  credentials: "same-origin", // Include credentials (default is "omit")
  cache: "no-cache", // Cache mode (default is "default")
  redirect: "follow", // Redirect mode (default is "follow")
};

fetch(url, options)
  .then….
JavaScript Promises are a way to handle asynchronous operations, such as fetching data from a server or reading data from a file, in a more readable and predictable way.
Promises
A Promise is an object that represents the eventual completion (or failure) of an asynchronous operation, and allows you to attach callbacks that will be executed when the operation is completed or when an error occurs.
A Promise has three states:
Pending: The initial state of a Promise before it is resolved or rejected.
Fulfilled: The state of a Promise when the operation is completed successfully.
Rejected: The state of a Promise when an error occurs during the operation.
A promise is created using the Promise constructor. The constructor takes a single argument, a function called the "executor," which takes two parameters: resolve and reject.
The resolve function is called when the asynchronous operation is successful, and it takes the resulting value as an argument. The reject function is called when the operation fails, and it takes an error as an argument.
Once a promise is created, you can attach callbacks to it using the .then() method. The .then() method takes two optional arguments, onFulfilled and onRejected, which are functions that will be called when the promise is fulfilled or rejected, respectively.
Promises allow for more readable and maintainable asynchronous code, as they avoid callback hell and provide a way to handle errors more elegantly.

const myPromise = new Promise((resolve, reject) => { // Perform an asynchronous operation, such as fetching data from a server or reading data from a file. // If the operation is successful, call the resolve() function and pass in the result. // If an error occurs, call the reject() function and pass in the error. });
const myPromise = new Promise((resolve, reject) => {
  // Simulate an asynchronous operation with a setTimeout
  setTimeout(() => {
    const randomNumber = Math.random();
    if (randomNumber > 0.5) {
      resolve(randomNumber);
    } else {
      reject(new Error('Random number is too low!'));
    }
  }, 1000); // wait 1 second before resolving/rejecting
});
You can attach callbacks to a Promise using the .then() and .catch() methods. The .then() method is called when the Promise is fulfilled, and the .catch() method is called when the Promise is rejected.
Here's an example:
myPromise .then(result => { // Do something with the result. }) .catch(error => { // Handle the error. });
Promises can afterwards  be chained with another .then() method, allowing you to perform multiple operations sequentially:
myPromise .then(result => { // Perform another asynchronous operation using the result. return anotherPromise; }) .then(anotherResult => { // Do something with the anotherResult. }) .catch(error => { // Handle the error. });
Promises are an important concept in modern JavaScript and are used extensively in many frameworks and libraries, such as React, Angular, and Node.js.
a JavaScript Promise is asynchronous.
A Promise is designed to handle asynchronous operations, such as fetching data from a server or reading data from a file, in a non-blocking way. When you create a Promise, the code inside the Promise constructor function is executed synchronously, but the Promise itself represents an asynchronous operation.
When a Promise is created, it enters the "pending" state, and then transitions to either the "fulfilled" or "rejected" state when the operation completes or when an error occurs. While the Promise is in the "pending" state, other code can continue to execute without waiting for the Promise to resolve.
You can attach callbacks to a Promise using the .then() and .catch() methods. These callbacks are executed asynchronously when the Promise is resolved or rejected. This means that they are added to the JavaScript event loop and executed when the event loop reaches them, after any other synchronous code has finished executing.
Here's an example:
const myPromise = new Promise((resolve, reject) => { setTimeout(() => { resolve("Hello, world!"); }, 1000); }); myPromise.then(result => { console.log(result); // "Hello, world!" });
 console.log("This code runs synchronously.");
In this example, the Promise is created with a timeout of 1000ms. The .then() callback is attached to the Promise, but it doesn't run until the Promise is resolved after 1000ms. Meanwhile, the "This code runs synchronously." message is logged to the console immediately, without waiting for the Promise to resolve.
The JavaScript event loop is the mechanism that handles the execution of code in a non-blocking, asynchronous way. When a script is executed, JavaScript maintains a call stack to keep track of function calls and their corresponding stack frames.
The event loop continuously checks for messages in a queue, which contains both macro tasks and micro tasks. When the call stack is empty, the event loop takes the first message from the queue and pushes it onto the call stack, executing it synchronously.
Micro tasks are tasks that are executed before the next paint of the browser. Micro tasks are typically used for tasks that need to be executed as soon as possible, such as updating the UI or handling Promises. Examples of micro tasks include Promise callbacks registered with .then(), and mutation observer callbacks.
Macro tasks are tasks that are executed later in the event loop, after the micro tasks have been executed. Macro tasks are typically used for tasks that are less time-critical, such as I/O operations or setTimeout() callbacks. Examples of macro tasks include setTimeout(), setInterval(), and requestAnimationFrame() callbacks, fetching data from server.
Here's an example of how micro tasks and macro tasks work in the event loop:
console.log('1'); 
setTimeout(() => { console.log('2'); }, 0); 
Promise.resolve().then(() => { console.log('3'); });
 console.log('4');
In this example, the console will output: 1 4 3 2
   <script>
      "use strict";
      console.log("start");
      setTimeout(() => console.log("setTimeout"), 0);
      Promise.resolve()
        .then(() => {
          console.log("Fetching data from server...");
          return fetch("https://jsonplaceholder.typicode.com/todos/1");
        })
        .then((response) => {
          console.log("Processing response data...");
          return response.json();
        })
        .then((data) => {
          console.log("Received data from server:", data);
        });
      console.log("end");
    </script>
OUTPUT:start end Fetching data from server… setTimeout Processing response data...Received data from server: {somedata}(checked in my browser) ete setTimeout-y dnum enq 1000, qalisa verj, ete poxum enq 10-> gnuma verev naxord texy, aysingn kaxvac te resp;onsy vorinna aveli arag galis, fetch te settimeout, da el arajinna linum.


Is async/await in JS is a promise?
No, async/await is not a promise, but rather a syntactical feature in JavaScript that simplifies asynchronous code by allowing developers to write asynchronous code that looks and behaves more like synchronous code.
async/await uses Promises under the hood to manage the asynchronous operations, but it is not a Promise itself. When an async function is called, it returns a Promise. The await keyword is used inside an async function to pause the execution of the function until a Promise is resolved or rejected. The await keyword essentially unwraps the resolved value of a Promise, allowing the code to continue running synchronously.
So, async/await is a way to write more readable and maintainable asynchronous code using Promises, but it is not a Promise itself.
example of promise with axios call in JS
const axios = require('axios');


function makeRequest(url) {
  return new Promise((resolve, reject) => {
    axios.get(url)
      .then(response => {
        resolve(response.data);
      })
      .catch(error => {
        reject(error);
      });
  });
}


makeRequest('https://jsonplaceholder.typicode.com/posts')
  .then(data => {
    console.log(data);
  })
  .catch(error => {
    console.error(error);
  });

Is then/catch is a promise in JS?
then and catch are methods of a Promise object in JavaScript, but they are not Promises themselves.
When a Promise is resolved or rejected, it returns a new Promise object with a then method that can be used to handle the resolved value and a catch method that can be used to handle any errors that may occur.
The then method takes one or two optional arguments, the first being a function that handles the resolved value, and the second being a function that handles any errors that may occur. The catch method takes a single argument, which is a function that handles any errors that may occur.
Here's an example:
const promise = new Promise((resolve, reject) => { 
setTimeout(() => { 
const randomNumber = Math.floor(Math.random() * 10); 
if (randomNumber % 2 === 0) { 
resolve(randomNumber); 
}else { 
reject(new Error('Random number is odd'));
 } 
}, 1000);
 }); 

promise .then(result => { console.log(`Resolved: ${result}`); }) 
.catch(error => { console.error(`Rejected: ${error.message}`); });
In this example, we create a new Promise that resolves with a random even number or rejects with an error if the number is odd. We then chain a then method to log the resolved value or a catch method to log the error message if the Promise is rejected. Note that neither then nor catch return Promises themselves, but rather a new Promise object is returned each time then or catch is called, allowing for chaining of these methods.
how is then() method in JS is a callback function when it is not passed as an argument?
The then method in JavaScript is a callback function in the sense that it is a function that is called in response to an event, which is the fulfillment of a Promise.
Although the then method is not passed as an argument to another function, it is still a function that is called in response to an event. When a Promise is fulfilled, it invokes the then method and passes it a callback function that should be executed with the fulfillment value. The then method then returns a new Promise that is fulfilled with the return value of the callback function, or rejected with the error thrown by the callback function.
A callback function or its reference is not always necessary to be passed as an argument
then() method in JavaScript is used to register a callback function that will be called when a Promise is fulfilled with a value. The then() method takes two arguments:
A callback function that will be called with the fulfillment value when the Promise is fulfilled. This callback function can take one argument, which is the fulfillment value.
An optional callback function that will be called if the Promise is rejected with an error. This callback function can take one argument, which is the error that caused the rejection.
The second argument of the then() method and the argument of the catch() method are similar in that they are both used to handle errors in Promises, but they are not exactly the same.
The then() method takes two arguments - the first argument is a callback function that will be called if the Promise is fulfilled, and the second argument is a callback function that will be called if the Promise is rejected. This means that you can handle both fulfillment and rejection in the same then() method call:

Is try/catch method is a promise in JS?
No, try/catch is not a Promise in JavaScript.
try/catch is a language construct in JavaScript that allows you to handle exceptions (i.e., errors) that occur within a block of code. The try block contains the code that may throw an exception, and the catch block contains the code that handles the exception if it occurs.
  let a = 2;
      const someFunctionThatMightThrowAnException = () => {
        if (a < 3) {
          return new Error("Random number is to little");
//if we write throw new Error("Random number is to little");
//we will have actual error in red in console.log
Error: Random number is to little


        } else {
          return "OK";
        }
      };
try {
  // code that may throw an exception
  const result = someFunctionThatMightThrowAnException();
  console.log(`Result: ${result}`);
} catch (error) {
  // code that handles the exception
  console.error(`Error: ${error.message}`);
}
In this example, we wrap a function call in a try block, and if an exception is thrown, it is caught and handled in the catch block. Note that try/catch does not return a Promise object, but rather it's a language construct that helps you handle exceptions in a more controlled way.
Promises, on the other hand, are a way to handle asynchronous operations in JavaScript, allowing you to write code that is more maintainable and easier to reason about. A Promise is an object that represents the eventual completion (or failure) of an asynchronous operation, and it provides a way to handle the result (or error) of that operation using the then and catch methods.
orinak karox enq mer uzac bloky/funkcian dnel try-i mej, u catch-ov brunel error. orinak inch vor funkcia unenq try-i mej undefined. 
kam menq throw anenq error-y
<input id="demo" type="text">
<button type="button" onclick="myFunction()">Test Input</button>
<p id="p01"></p>

<script>
function myFunction() {
  const message = document.getElementById("p01");
  message.innerHTML = "";
  let x = document.getElementById("demo").value;
  try { 
    if(x.trim() == "") {
    throw "empty";}
    else if(isNaN(x)) throw "not a number";
    else if(Number(x)<5 || Number(x)>10){
     throw "should be between 5 and 10";
    }else{
    message.innerHTML = "ok ya"
    } 
  }
  catch(err) {
    message.innerHTML = "Input is " + err;
  }
}
</script>

axios.get() always returns a Promise object.
When you make a GET request using axios, the response you get back is an object that represents the HTTP response. This object typically has a number of properties such as data, status, headers, config, and request.
The data property is the one that contains the response body. This property will have a different value depending on the type of response you get back. For example, if you're making a request to a JSON API, the data property will contain the parsed JSON response.
If there is an error or an exception during the request, axios.get() may not return an object, and instead throw an error. It's important to handle such errors in your code to prevent your application from crashing.
So while axios.get() usually returns an object, it's important to handle any errors that may occur during the request.
so we can chain it with then().catch() methods`
axios.get('/api/data') .then(response => { console.log(response.data); }) .catch(error => { console.log(error); });
Chaining then() and catch() methods allows you to handle both success and error responses in a more organized and efficient way.
Is a js callback function asyncronous?
Not all JavaScript callback functions are asynchronous. Whether a callback function is asynchronous or not depends on the context in which it is used and how it is implemented.
In general, a callback function is a function that is passed as an argument to another function and is executed when that function completes its task. The callback function can be either synchronous or asynchronous, depending on how it is defined.
In summary, a callback function in JavaScript is a function that is passed as an argument to another function and is executed when the first function completes its task. Callback functions are commonly used to handle asynchronous operations and to allow the calling callback function to continue executing while the callback function completes its task asynchronously.
example of async callback->
function getDataFromApi(url, callback) {
  fetch(url)
    .then(response => response.json())
    .then(data => {
      callback(data);
    })
    .catch(error => {
      console.error(error);
    });
}

function displayData(data) {
  console.log(data);
}

getDataFromApi('https://api.example.com/data', displayData);

example of sync callback->
function processNumbers(numbers, callback) {
  const results = [];
  for (let i = 0; i < numbers.length; i++) {
    results.push(callback(numbers[i]));
  }
  return results;
}

function doubleNumber(num) {
  return num * 2;
}

const numbers = [1, 2, 3, 4, 5];
const doubledNumbers = processNumbers(numbers, doubleNumber);
console.log(doubledNumbers);
This is an example of a synchronous callback function because the callback function is executed immediately in the main function and there is no delay or asynchronous operation involved. The execution of the main function is blocked until the callback function has completed its task on each element in the array.




React
-has a component based architecture. In React, component names are conventionally written in uppercase letters. This is because React treats components starting with lowercase letters as HTML tags, and components starting with uppercase letters as custom components.
-components (are stand alone parts of UI) are reusable, yet behave independently. 2 types of components(functional and class)
-provides something called virtual dom(in memory representation or clone of the real dom)
React uses Virtual dom to update browser Dom only when needed. to increase the app speed.
benefits
1.high performance rendering
2.huge community, easier to find solutions to the problems
3.easy to manipulate with dom (avoiding spaghetti code)

What is jsx?
JSX is an extension to JavaScript syntax that allows you to write HTML-like code in your JavaScript files when building user interfaces in React. It stands for JavaScript XML because it combines the syntax of both JavaScript and XML.
JSX allows you to write code that looks like HTML, but is actually JavaScript. You can use HTML-like tags and syntax to define components, which are the building blocks of React applications. For example, here is a JSX code snippet that defines a component in React:
>JSX is not a requirement for building React applications, but it makes it easier to write and read code for building user interfaces. When you write JSX code, it needs to be transpiled into regular JavaScript by a tool such as Babel before it can be run in a browser.
JSX also allows you to embed JavaScript expressions within the HTML-like syntax, by wrapping them in curly braces {}. This makes it easy to dynamically generate content and manipulate the appearance of your components based on data or user interactions. 
In React, there are two main types of exports: default exports and named exports.
1.Default Exports: A module can have only one default export, which can be a function, class, or object. When importing a default export, you can give it any name you want.
2.Named Exports: A module can have multiple named exports, which are variables, functions, or classes that are explicitly named. When importing named exports, you need to use the exact name that was given to them.
a module is a file that exports code, (A module can contain one or more components, along with other exported functions, objects, or values.) 
while a component is a specific type of exported value that represents a UI element. Components are the building blocks of a React application, and modules are used to organize and share code between different parts of the application.and they can be composed together to create more complex UIs. Each component typically has its own state and props, which determine its behavior and appearance. Components can also be nested inside each other to create a tree-like structure of UI elements.

components can be controlled and uncontrolled
A controlled component is a component that manages its state through props passed down by its parent. In other words, the parent component has full control over the state of the child component. Whenever the child component needs to update its state, it has to call a function provided by the parent component.
components that don't have state are stateless.

props and states are plain JS objects. props that are received from parents are immutable. State manages internally. change rerenders the component.
controlled component can’t change. in case of change they both trigger render update.

context api
Context API is a feature in React that allows data to be passed down the component tree without the need to pass props manually at every level. It provides a way to share data among components without having to pass props through intermediate components.
Context is essentially a global variable that is accessible to all components in a React application. Context is created using the createContext() method provided by the React object. The createContext() method returns a Context object, which can be used to share data among components.
import React, { createContext } from 'react';

// Create a context object
const MyContext = createContext();

function MyProvider(props) {
  const data = { message: 'Hello, world!' };
  return (
    <MyContext.Provider value={data}>
      {props.children}
    </MyContext.Provider>
  );
}
// Create a consumer component
function MyConsumer() {
  return (
    <MyContext.Consumer>
      {data => <div>{data.message}</div>}
    </MyContext.Consumer>
  );
}
Context API provides two components: Provider and Consumer, to create and use context. The Provider component is used to provide data to all the child components, and the Consumer component is used to consume the data provided by the Provider. The Provider and Consumer components are used together to create and consume context.
On the other hand, useContext is a hook that provides a way to consume context in a functional component. It allows a component to read the current value of a context without the need for a Consumer component.
// Use the useContext hook importing MyContext
function MyConsumer() {
  const data = useContext(MyContext);
  return <div>{data.message}</div>;
}
In larger applications to manage global state it  is better to use a state management library as redux(is more structured and stores data in the store, and convenient to for managing global state), but context aPI STILL can be used simultaneously for subtrees, 
to avoid props drilling problem.

REACT Fibers
React Fibers is a feature of React that helps improve the performance and responsiveness of React applications. It works by breaking down the rendering process into smaller units of work called "fibers", which can be prioritized based on their importance.
When a React component is rendered, it creates a virtual representation of the user interface using a fiber tree. This fiber tree is used to track changes to the user interface and determine which parts of the tree need to be updated when something changes.The fiber tree is a virtual representation of the component hierarchy, with each fiber representing  a portion of the user interface that needs to be updated.
React Fibers allows React to prioritize which parts of the fiber tree need to be updated first and how to handle user interactions more efficiently. It can also pause and resume work on different parts of the fiber tree based on their priority and available resources.
Overall, React Fibers help to make React applications more responsive and efficient, especially for complex user interfaces with a large number of components.
The main difference between the virtual DOM tree and the fiber tree is that the virtual DOM tree represents the actual HTML DOM tree, while the fiber tree represents the work that needs to be done to update the virtual DOM tree. The virtual DOM tree is used to efficiently update the actual HTML DOM tree, while the fiber tree is used to prioritize and schedule the work that needs to be done to update the virtual DOM tree.
React Fibers also provide a way to implement more advanced features such as Suspense, which allows components to specify fallback content while they are loading data or other asynchronous resources. Suspense uses fibers to track the progress of the asynchronous work and determine when to show the fallback content and when to show the final content.


REACT HOOKS 10 hooks
useCallback is a hook in React that returns a memoized version of a function, so that it can be used as a dependency in other hooks or components without triggering unnecessary re-renders.
Here's an example of using useCallback:
how to figure out when to use useCallback hook
Here are a few guidelines to help you figure out when to use the useCallback hook:
In general, it's a good idea to use useCallback when you have a function that is expensive to create or has a lot of dependencies, and when you want to optimize the performance of your application. However, it's important to keep in mind that premature optimization can sometimes lead to more complex code that is harder to maintain, so it's important to balance performance considerations with simplicity and maintainability.
Practical use cases for useCallback
1.when Passing functions to child components: to memorize the function and avoid unnecessary re-renders.If the function is simple and doesn't reference any props or state from the parent component, it may not be necessary to memoize it. In this case, the function can be passed down as a prop to the child component directly,
const ParentComponent = () => {
  const handleClick = useCallback(() => {
    console.log('Clicked');
  }, []);

  return <ChildComponent onClick={handleClick} />;
};
const ChildComponent = ({ onClick }) => {
  return <button onClick={onClick}>Click me</button>;
};
2.Event listeners: When you attach event listeners to DOM elements in React, it is important to use useCallback to prevent unnecessary re-renders.This is because event listeners are attached to DOM elements every time the component is re-rendered, and passing a new function to an event listener every time can cause unnecessary re-renders.

const MyComponent = () => {
  const handleClick = useCallback(() => {
    console.log('Clicked');
  }, []);

  useEffect(() => {
    document.addEventListener('click', handleClick);
    return () => {
      document.removeEventListener('click', handleClick);
    };
  }, [handleClick]);

  return <div>Click anywhere to log a message</div>;
};
The dependencies array is optional, but it's an important part of using useCallback correctly. If you don't provide a dependencies array, the memoized function will be recomputed on every render, which can lead to performance issues.
When you pass an empty array [] as the second argument to useCallback, it tells React that the memoized function returned by useCallback should never be recomputed.
3.Expensive calculations: If you have a function that performs an expensive calculation, you can use useCallback to memorize the function and avoid unnecessary re-calculations.
const MyComponent = ({ data }) => {
  const calculateAverage = useCallback(() => {
    // Perform expensive calculation
    return data.reduce((acc, val) => acc + val) / data.length;
  }, [data]);
4.Optimizing use of useEffect: If you have a useEffect dependency array that includes a function, it's a good idea to use useCallback for that function, in order to prevent unnecessary re-rendering.
const MyComponent = ({ fetchData }) => {
  const handleFetch = useCallback(() => {
    fetchData();
  }, [fetchData]);
if you have multiple dependencies or if the data fetching function is complex, it can be more efficient to pass the function as a dependency to useEffect. 
  useEffect(() => {
    handleFetch();
  }, [handleFetch]);
  return <div>Fetching data...</div>;
};

useMemo
useMemo is a React hook that is used to optimize the performance of your application by memoizing the result of a function. It can be used in situations where a component is rendering the same result every time it is re-rendered, even if the inputs to the component have not changed. Here are some practical cases where useMemo can be useful:
1.Computing derived data: If you have a component that needs to compute some derived data from its props or state, you can use useMemo to memorize the result of the computation. This can be useful if the computation is expensive and you don't want it to be re-computed on every re-render of the component.
function MyComponent({ data }) {
  const derivedData = useMemo(() => {
    // expensive computation
    return data.map(item => item * 2);
  }, [data]);
`useMemo is used to memoize a value that is computationally expensive to calculate.
useCallback is used to memoize a function that is expensive to create. 
memo() HOC
When we have 2 components, parent and child. Child is stateless, it gets its state from the parent, Parent has 2 states, one for it, one is passing to a child as prop(example number), every time when we try to change the parent's state, the child is also rendered. We can use memo HOC and wrap the child to prevent the child component’s rendering`
export default memo(Child);

But if we pass the setChildNumber () as a prop to the child-> it starts rendering again, when the parent's state is changing. This is because of referential equality. (the setChildNumber function, which is passed to the child from parent is not the same anymore, (the prop of the child is changing, that’s why it is being additionally rendered) const x=’’bla”, const y=’’bla”, x===y-> true
x={key:”bla”}, y=x, x===y-> true (checks the referential equality, and it is true)
x={key:”bla”}, y={key:”bla”}, x===y->false (checks the referential equality, x and y refer to different objects),
Same is for the function, every time the component(parent) renders, the function is creating again, and starts to point to a  value of different address. The props of the child component is changing, and it's being rendered.That's why by using useCallback the child component doesn’t render
const [parentNum, setParentNum] = useState(0);
  const [childNumNum, setChildNumNum] = useState(0);


  const changeParentNum = () => {
    setParentNum(Math.round(Math.random() * 10));
    console.log("parent func rendered");
  };
  const changeChildNum = (number) => {
    setChildNumNum(number);
    console.log("child func rendered");
  };
  console.log("rendered parent");
  return (
    <div>
      <h2>Parent: {parentNum} </h2>
      <button onClick={changeParentNum}>Change parent num</button>
      <Child changeNum={changeChildNum} number={childNumNum} />
    </div>
 Now, if we add an array to the parent component( const arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12];
), and a function which calculates and returns the biggest number of the array, 
 const getLargestNumber = () => {
    console.log("I am working");
    return Math.max(...arr);
  };

and put the <h3>{getLargestNumber()}</h3>
It will work every time if we change the state for parent, or for child component.
If we write the func with useMemo saving the array state as dependency, the function will not create in every render of the component.
const getLargestNumber = useMemo(() => funct(), [arr]);
  function funct() {
    console.log("I am working");
    return Math.max(...arr);
  }
NOte that if we have array as just a variable, it will not work, because in every render a new array will be created. And the function will created as well, because we have arr constant as a dependency: but if we store the array in the state->const [arr, setArr] = useState([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]);
And when we use setState to change the array value the getLargestNumber function will be created again.
useEffect VS useLayoutEffect
useEffect and useLayoutEffect are both hooks in React that allow you to execute side effects in response to changes in a component's props or state. However, there are some key differences between them that make them useful in different scenarios.
The primary difference between useEffect and useLayoutEffect is when they are executed in the component lifecycle. useEffect is executed after the component has been rendered and painted on the screen, while useLayoutEffect is executed before the component has been painted on the screen.
The practical implication of this difference is that useLayoutEffect can be used to perform side effects that need to be executed synchronously, such as measuring the size of a DOM element or setting up a canvas for drawing. If you need to perform a side effect that depends on the layout or styling of a component, and you need the result of that side effect before the component is painted on the screen
 useLayoutEffect(() => {
    const div = document.getElementById('my-div');
    const rect = div.getBoundingClientRect();
    setSize({ width: rect.width, height: rect.height });
  }, []);getBoundingClientRect() is a method in JavaScript that returns the size of an element and its position relative to the viewport.

useReducer()
useReducer is a built-in React hook that allows you to manage state in a functional component using a reducer function. It is similar to useState, but provides a more powerful and flexible way to manage complex state changes.
The useReducer hook takes two arguments: a reducer function and an initial state value. The reducer function takes two arguments: the current state and an action object, and returns a new state based on the action. You can dispatch actions to the reducer using a dispatch function that is returned by the useReducer hook.
import React, { useReducer } from 'react';


function reducer(state, action) {
  switch (action.type) {
    case 'increment':
      return { count: state.count + 1 };
    case 'decrement':
      return { count: state.count - 1 };
    default:
      throw new Error();
  }
}


function Counter() {
  const [state, dispatch] = useReducer(reducer, { count: 0 });


  return (
    <div>
      <p>Count: {state.count}</p>
      <button onClick={() => dispatch({ type: 'increment' })}>+</button>
      <button onClick={() => dispatch({ type: 'decrement' })}>-</button>
    </div>
  );
}
useImperativeHandle: allows a parent component to interact with a child component's instance through a ref
In parent component` 
 const childRef = useRef(null);


  const handleClick = () => {
    childRef.current.increment();
  };
     <div>
      <MyChildComponent ref={childRef} />
      <button onClick={handleClick}>Increment child count</button>
    </div>


In child component`
import React, { forwardRef, useImperativeHandle } from 'react';


const MyChildComponent = forwardRef((props, ref) => {
  const [count, setCount] = useState(0);


  const increment = () => {
    setCount(count + 1);
  };


  useImperativeHandle(ref, () => ({
    increment
  }));


  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={increment}>Increment</button>
    </div>
  );
});


Button in parent component and btn in child component do the same


useDebugValue(debug custom hook in react dev tools)
The useDebugValue hook takes a single argument, which is the value that should be displayed in React DevTools. This value can be any type, such as a string, object, or function. The hook should be called inside a custom hook that needs to be debugged.
import { useDebugValue, useState } from 'react';


function useCounter(initialValue) {
 const [count, setCount] = useState(initialValue);


  useDebugValue(`Count: ${count}`);
const increment = () => setCount(count + 1);


  return { count, increment };
}

REACT ROUTER 6.4+
Introduces many new features simplifies data fetching and data submission.
Data fetching:we can get rid of error and loading states, useEffect with data fetching function
1.(Blog Posts page)Add a new function loader in a component, where the data should be got, with export

export function loader(){
return getPosts()
}
2.Register the function on our route definition, Add a function as a prop to the corresponding route.
Import {loader as blogLoader} from “......”

<BrowserRouter> -> should be changed to routerProvider
     <RootLayout> ->layout component
<Routes>
	<Route path=”/” element={<WelcomePage/>} />
<Route path=”/blog  element={<BlogLayout />}>
	<Route index element={<BlogPostsPage/>} loader={blogLoader} 
 />
	<Route path=”:id” element={<PostDetailPage/>} errorElement={<p>there is an error</p> />->add error to route
</Route>
</Routes>
     </RootLayout> 
</BrowserRouter>

React router will automatically call this function whenever we navigate to BlogPostspage and data will be available in it.
3.In (Blog Posts page)We just have to use a special hook.(useLoaderData)
Import {useLoaderData} from “react-router-dom”

	const loaderData = useLoaderData;
loaderData is the data we got from the loader() function.
4.The data is not yet available we should change browserRouter to new RouterProvider, this is a self-closing component, we should just close it

Import {RouterProvider, createbrowserRouter, createRoutesFromElements, Route, Routes} from “react-router-dom”

const router=createBrowserRouter([{path: ‘/’ element:<WelcomePage/>}])-> every object in this arr will represent one route.

But alternatively it is better to import createRoutesFromElements function as well, and call it as callBack
const router=createBrowserRouter(createRoutesFromElements())-> and all the route definitions we should pass as arg like this:
Declare router variable outside the App() function
const router=createBrowserRouter(createRoutesFromElements(
<Route path=”/” element={<RootLoayout />}> -> changing Routes to Route allows us to pass our custom  layout component
	<Route index element={<WelcomePage/>} />
<Route path=”/blog  element={<BlogLayout />}>
	<Route index element={<BlogPostsPage/>} loader={blogLoader} />
	<Route path=”:id” element={<PostDetailPage/>} />
</Route>
</Route>-> changed to route
))
Instead of Routes we use Route as the parent component for all the routes. And pass path=”/” element={<RootLoayout />} props.
Index listens to “/” block, and activates its route.
In order of RootLoayout in work, we should remove {children} prop from the component. Instead import outlet:
Import {Outlet} from “react-router-dom”;

return(
<>
<NavBar/>
  <main>
      <Outlet/>
   </main>
</>
)
The final app component`
function App() {
  const router = createBrowserRouter(
    createRoutesFromElements(
      <Route path="/" element={<RootLayout />} errorElement={<Error />}>
        <Route index element={<Home />} />
        <Route path="/blog">
          <Route index element={<BlogList />} loader={blogLoader} />
          <Route
            path=":id"
            element={<BlogDetail />}
            loader={singleBlogLoader}
          />
        </Route>
        <Route path="/news" element={<News />} />
        <Route path="/newPost" element={<NewPost />} />
      </Route>
    )
  );
  return <RouterProvider router={router} />;
}

5.Pass our created rout variable to App() component
function App(){
return <RouterProvider router={router} />
}

Don't need for useEffect, loading page  Components will be rendered after fetching the data, less code to write.
We can still get rid of the useEffect and error, loading states 
Example in our PostDetails page 
Below the main component write a loader function

export function loader({ params }) { 
-> attention we dont use useParams anymore, we can get params from props
  return getSingleBlog(params.id);
}

For showing error, there is we can define errorElement prop of the route
errorElement={<someComponent/>or <div>message  error </div>}
In order not to add errorElement to each route, we can write this prop in a parent route.
We can also access the error message get by server, by using useRouteError hook

For form submission rr 6.4+ introduces Form component
const submitFunc = (e) => {
    e.preventDefault();
  };
  return (
    <form onSubmit={submitFunc}->delete  method="post" action="/newPost"
> instead form we import Form from react-router-dom
      <input type="text" placeholder="title" name="title" />
      <input type="text" placeholder="text" name="text" />
      <br />
      <button type="submit">Submit</button>
    </form>

In our case we use method ‘post’ and action, which should define the current path ‘/newPost’.It is client side and action doesn’t send the request to backend. This will generate a request object, with formdata. Which we will then forward to backend.
Below in this same file we should export function action. And then in app component we should register this action function, with action property. And whenever we go to this route this function will be evoked.
import NewPost, { action as newPostAction } from "../src/pages/NewPost";

<Route path="/newPost" element={<NewPost />} action={newPostAction} />

The export const action = async() => {};function in the component will have automatically generated object with our form data as its parameter.
 We’ll be able to extract datas by the names.
Final action function->
import { Form, redirect } from "react-router-dom";-> redirect is also new feature in react router


export const action = async ({ request }) => {
  const formData = await request.formData();
  const post = {
    title: formData.get("title"),
    body: formData.get("text"),
  };
  try {
    await savePost(post);
  } catch (err) {
    console.log(err);
    throw err;
  }
  return console.log({ post }), redirect("/newPost");-> should be return this route, or another page
};

Displaying loader when fetching data.
1.we can block the code from for some time by using a custom function

SCSS with react
———————————
npm i node-sass
Npm i-i jamanak yooremit
Node sass-y 

___________

just redux(not toolkit) for typescript


npm install redux react-redux redux-thunk @types/react-redux


npm install react-redux
npm install --save-dev @redux-devtools/core

React redux toolkit
(link https://redux-toolkit.js.org/tutorials/quick-start)
youtube(https://www.youtube.com/watch?v=iBUJVy8phqw&t=2s)
1.Install Redux Toolkit and React-Redux​
npm install @reduxjs/toolkit react-redux
(im mot tvec error, vory ancav` npm install --no-optional, heto nor npm install @reduxjs/toolkit react-redux )
2.create src/app/store.js.
3.inside store.js
import { configureStore } from "@reduxjs/toolkit";


export const store = configureStore({
  reducer: {},
});
4.in index.js wrap the <App />
…
import { store } from "./app/store";
import { Provider } from "react-redux";


ReactDOM.render(
  <React.StrictMode>
    <Provider store={store}>
      <App />
    </Provider>
  </React.StrictMode>,
  document.getElementById("root")
);

5.in CounterSlice.js
import { createSlice } from "@reduxjs/toolkit";
export const counterSlice = createSlice({
  name: "counter",
  initialState: {
    count: 0,
  },
  reducers: {
    increment: (state) => {
      state.count += 1;
    },
    decrement: (state) => {
      state.count -= 1;
    },
    incrementByAmount: (state, action) => {
      state.count += action.payload;
    },
  },
});
export const { increment, decrement, incrementByAmount } = counterSlice.actions;
export default counterSlice.reducer;


6. In store.js
export const store = configureStore({
  reducer: {
counter:counterSlice},
});
7.And in our file->
import { useDispatch, useSelector } from "react-redux";
import React from "react";
import { decrement, increment, incrementByAmount } from "../redux/CounterSlice";


export const CounterRedux = () => {
  const { count } = useSelector((state) => state.counter); //we want destructure count from counter
  const dispatch = useDispatch();
  return (
    <div>
      <h2>Counter with Redux</h2>
      <h3>our count is {count}</h3>
      <button onClick={() => dispatch(increment())}>Increment</button>
      <button onClick={() => dispatch(decrement())}>Decrement</button>
      <button onClick={() => dispatch(incrementByAmount(30))}>
        increment by 30
      </button>
    </div>
  );
};

redux with typescript-> setting input value with dispatch
->
<input onChange={(e: React.ChangeEvent<HTMLInputElement>) =>
                dispatch(setCompanyName(e.target.value))
              }
            />

Redux toolkit crud  app
(additional redux project https://codedamn.com/learn/reactjs-projects/project-1-creating-a-hero/project-structure.wJeowEVIKI)
(Create, Read, Update, and Delete (CRUD)  user data)

What is CRUD?
Create, Read, Update, and Delete (CRUD) are the four basic functions that models should be able to do, at most.
1.npm install react-redux @reduxjs/toolkit
(reducers are functions that we can call to provide some actions to our state)
index.js
import React from "react";
import ReactDOM from "react-dom";
import App from "./App";
import { configureStore } from "@reduxjs/toolkit";
import { Provider } from "react-redux";
import userReducer from "./features/users";


const store = configureStore({
 reducer: {
   users: userReducer,
 },
});
ReactDOM.render(
 <React.StrictMode>
   <Provider store={store}>
     <App />
   </Provider>
 </React.StrictMode>,
 document.getElementById("root")
);
app.js
import { useState, useRef  } from "react";
import { useDispatch, useSelector} from "react-redux";
import "./App.css";
import { addUser, deleteUser, updateUser } from "./features/users";


function App() {
 const userList = useSelector((state) => state.users.value);
 const dispatch = useDispatch();
 const [name, setName] = useState("");
 const [userName, setUserName] = useState("");
 const [newUserName, setNewUserName] = useState("");


 const handleChangeName = (e) => {
   setName(e.target.value);
 };
 const handleChangeUserName = (e) => {
   setUserName(e.target.value);
 };
 const handleNewChangeUserName = (e) => {
   console.log(e.target.value);
   setNewUserName(e.target.value)
 };
 return (
   <div className="App">
     <h3>red-tol-graph</h3>
     <div className="add-user">
       <input
         type="text"
         placeholder="Name Surname..."
         onChange={handleChangeName}
       />
       <input
         type="text"
         placeholder="UsernameName..."
         onChange={handleChangeUserName}
       />
       <button
         onClick={() =>
           dispatch(
             addUser({
               id: userList[userList.length - 1].id + 1,
               name: name,
               username: userName,
             })
           )
         }
       >
         Add User
       </button>
     </div>
     <div>
       {userList.map((item) => (
         <div className="display-users" key={item.id}>
           <div>{item.username}</div>
           <div>{item.name}</div>
           <input
             type="text"
             placeholder="Change username..."
             onChange={handleNewChangeUserName}
           />
           <button onClick={()=>dispatch(updateUser({id:item.id, username:newUserName}))}>Update</button>
           <button onClick={()=>dispatch(deleteUser({id:item.id}))}>Delete</button>
         </div>
       ))}
     </div>
   </div>
 );
}


export default App;


features/user.js
import { createSlice } from "@reduxjs/toolkit";
import { UsersData } from "../FakeData";


export const userSlice = createSlice({
 name: "users",
 initialState: {
   value: UsersData,
 },
 reducers: {
   addUser: (state, action) => {
     state.value.push(action.payload);
   },
   deleteUser: (state, action) => {
     state.value = state.value.filter((item) => item.id !== action.payload.id);
   },
   updateUser: (state, action) => {
     state.value.forEach((user) => {
         if(user.id===action.payload.id && action.payload.username.length>0){
             user.username=action.payload.username;
         }
     });
   },
 },
});
export default userSlice.reducer;
export const { addUser, deleteUser, updateUser } = userSlice.actions;

—-----------------------------------------------------------------------------------
Format on save 
https://www.youtube.com/watch?v=zd_aDbwr4pY
Cntr + , ->bacuma settings VScode-um.
Text editor dropdown sexmum enq yntrum enq formatting-y
Checkbox format on save nshum enq
Prettier code formater install
Chi ashxati, qani vor json-um piti popoxutyunner anel
Settings-i formattingi mej nex vernagir Formatting-i verevum link ka Edit in settings.json
bacum enq verjic avelacnum`
"editor.defaultFormatter": "esbenp.prettier-vscode",

Fetch api with axios
In ReactJS, Axios is a library that serves to create HTTP requests that are present externally. It is evident from the fact that we may sometimes in React applications need to get data from the external source. ... Additionally, react Axios is very easy to modify and is quite lightweight.

npm install axios


import React, { useEffect, useState } from "react";
import axios from "axios";


const api = axios.create({
  baseURL: "https://jsonplaceholder.typicode.com/todos",
});


export const AxiosComponent = () => {
  const [fetchedData, setFetchedData] = useState("");
  const handleData = () => {
    api.get("/1").then((res) => {
      setFetchedData(res.data.title);
    });
  };


  return (
    <div>
      <h1>Axios</h1>
      {/* <div>{fetchedData}</div> */}
      <button onClick={handleData}>fetch data</button>
      <div>{fetchedData}</div>
    </div>
  );
};
or just` 
2.axios.get().then
import React, { useEffect, useState } from "react";
import axios from "axios";


export const UseEffect = () => {
 const [data, setData]=useState('');
 useEffect(() => {
   axios
     .get("https://jsonplaceholder.typicode.com/comments")
     .then((response) => {
       console.log(response.data[0].email);
       setData(response.data[0].email);
     });
 }, []);
 return (
   <div>
     <h3>UseEffect hook</h3>
     <span>{data}</span>
   </div>
 );
};
3.config.js
export const axiosInstance = axios.create({
 baseURL,
 timeout: 60000,
});
 
room.api
import { axiosInstance } from '../config';


export const roomSit_req = async (roomId) => {axi
 const response = await axiosInstance.post(`/game/join`, {
   roomId,
 });
 return response.data;
};





const gameRoom = async (id) => {
   const gameRoomData = await roomSit_req(id);
   console.log('gameRoomData', gameRoomData);
   if (gameRoomData.data.allowPlay) {
     dispatch(navigate(ScenesEnum.GAME_PLAY));
   }
   console.log('gameRoomData', gameRoomData);
 };


API Status Codes
All of these status responses are returned in JSON format.
Example Response
{
  "success": false,
  "status_code": 7,
  "status_message": "Invalid API key: You must be granted a valid key."
}

Code
HTTP Status
Message
1
200
Success.
2
501
Invalid service: this service does not exist.
3
401
Authentication failed: You do not have permissions to access the service.
4
405
Invalid format: This service doesn't exist in that format.
5
422
Invalid parameters: Your request parameters are incorrect.
6
404
Invalid id: The pre-requisite id is invalid or not found.
7
401
Invalid API key: You must be granted a valid key.
8
403
Duplicate entry: The data you tried to submit already exists.
9
503
Service offline: This service is temporarily offline, try again later.
10
401
Suspended API key: Access to your account has been suspended, contact TMDB.
11
500
Internal error: Something went wrong, contact TMDB.
12
201
The item/record was updated successfully.
13
200
The item/record was deleted successfully.
14
401
Authentication failed.
15
500
Failed.
16
401
Device denied.
17
401
Session denied.
18
400
Validation failed.
19
406
Invalid accept header.
20
422
Invalid date range: Should be a range no longer than 14 days.
21
200
Entry not found: The item you are trying to edit cannot be found.
22
400
Invalid page: Pages start at 1 and max at 1000. They are expected to be an integer.
23
400
Invalid date: Format needs to be YYYY-MM-DD.
24
504
Your request to the backend server timed out. Try again.
25
429
Your request count (#) is over the allowed limit of (40).
26
400
You must provide a username and password.
27
400
Too many append to response objects: The maximum number of remote calls is 20.
28
400
Invalid timezone: Please consult the documentation for a valid timezone.
29
400
You must confirm this action: Please provide a confirm=true parameter.
30
401
Invalid username and/or password: You did not provide a valid login.
31
401
Account disabled: Your account is no longer active. Contact TMDB if this is an error.
32
401
Email not verified: Your email address has not been verified.
33
401
Invalid request token: The request token is either expired or invalid.
34
404
The resource you requested could not be found.
35
401
Invalid token.
36
401
This token hasn't been granted write permission by the user.
37
404
The requested session could not be found.
38
401
You don't have permission to edit this resource.
39
401
This resource is private.
40
200
Nothing to update.
41
422
This request token hasn't been approved by the user.
42
405
This request method is not supported for this resource.
43
502
Couldn't connect to the backend server.
44
500
The ID is invalid.
45
403
This user has been suspended.
46
503
The API is undergoing maintenance. Try again later.
47
400
The input is not valid.

200 - good
400 - I mest up something
500 - something wrong with server


—--------------------------------------------------------------------------------------------


REACT ROUTER DOM
npm i react-router-dom
index.js`
import { BrowserRouter } from "react-router-dom";
 <BrowserRouter>
        <App />
    </BrowserRouter>


app js`
import { Route } from "react-router";
import { Routes } from "react-router-dom";
import { SingleCharacter } from "./pages/singleCharacter";
function App() {
  return (
    <div className="App">
      <Routes>
        <Route path="/" element={<CharacterList />} />
        <Route strict exact path="/:id" element={<SingleCharacter />} />
      </Routes>
    </div>
  );
}

link
     import { Link } from "react-router-dom";
import { NavLink } from "react-router-dom";


NOTE: use navlink instead Link which by default adds and removes active class
Thats why we dont use activeclassName attribute as before, and we change active atim style like this:
 [aria-current='page'] {
      color: #5c0e80;
  }

<NavLink to="/">Home</NavLink> 
<Link to="/">Home</Link> 
     


Redux
https://redux-toolkit.js.org/introduction/getting-started

https://www.youtube.com/watch?v=iBUJVy8phqw
https://redux-toolkit.js.org/introduction/getting-started (pedro tech)


An API can be accessed through a URI (Uniform Resource Identifier) or a URL (Uniform Resource Locator),
So, a URL is a type of URI that provides specific details on how to access a resource. It includes the information necessary to retrieve the resource, such as the protocol, the domain name, and the path. 
URI Examples:
mailto:john.doe@example.com
tel:+1-555-555-5555
urn:isbn:9780134494166
data:text/plain;charset=utf-8,Hello%20World!
URL Examples:
https://www.example.com/index.html
ftp://ftp.example.com/file.txt
http://localhost:3000/api/users/1
https://maps.google.com/maps?q=New+York+City
In each of these examples, the URI or URL uniquely identifies a resource,

Graphql

https://www.youtube.com/watch?v=gAbIQx26wSI (laith harb)
https://rickandmortyapi.com/graphql // api to connect fake server

Graphql makes us get only the information needed.(ex username), with exact queries. Is a query language which provides connection between server and browser(client). and allows a more flexible approach than restful approach.(we get a concrete nested information of what we need with a query using one endpoint). Unlike sql(which exists between backend and DB) graphql  exists between client and server. front and back. it queries api, not the DB. ApI then connects the DB.
(GET -> query)(PUT(update), DELETE, POST->mutations ).

Unlike other rest api methods, graphql uri-s have only one endpoint->/graphql, so that we can get or send corresponding data.
1.install dependencies
npm install @apollo/client 
npm install graphql (kam mi toxov es erkusy npm install @apollo/client graphql)

2.Connect the project to a server
import { ApolloClient, InMemoryCache, ApolloProvider } from "@apollo/client";

const client = new ApolloClient({
  uri: "https://rickandmortyapi.com/graphql",
  cache: new InMemoryCache(), //this is why we call api once and then it stays in memory
});
ReactDOM.render(
  <React.StrictMode>
    <ApolloProvider client={client}>
      <App />
    </ApolloProvider>
  </React.StrictMode>,
  document.getElementById("root")
);



3. creating the first query
import React from "react";
import { useQuery, gql } from "@apollo/client";


const GET_CHARACTERS = gql(`
query{
    characters{
        results{
            id
            name
            image
        }
    }
}`);


export const CharacterList = () => {
  const { error, loading, data } = useQuery(GET_CHARACTERS);
  console.log("error", error, "loading", loading, "data", data);
  if (loading) return <div>spinner .......</div>;
  if (error) return <div> something went wrong</div>;
  return (
    <div>
      {data.characters.results.map((el) => (
        <>
          <div>{el.name}</div>
          <img src={el.image} alt="#" />
        </>
      ))}
    </div>
  );
};
but if we want to use this query more than in one place in app, we shouldnt create in inside every component we need, we must create our own custom hook.
So that we can use this hook anywhere we need.
1.create customHooks folder
inside it useCharactersHook.js file
import { useQuery, gql } from "@apollo/client";


const GET_CHARACTERS = gql(`
query{
    characters{
        results{
            id
            name
            image
        }
    }
}`);


export const useCharactersHook = () => {
  const { error, loading, data } = useQuery(GET_CHARACTERS);
  return { error, loading, data };
};


2.inside of component file`
import { useCharactersHook } from "../customHooks/useCharactersHook";


export const CharacterList = () => {
  const { error, loading, data } = useCharactersHook();


  if (loading) return <div>spinner .......</div>;
  if (error) return <div> something went wrong</div>;
  return (
    <div>
      {data.characters.results.map((el) => (
        <>
          <div>{el.name}</div>
          <img src={el.image} alt="#" />
        </>
      ))}
    </div>
  );
};
 BY CLICKING THE CHARACTER  NAVIGATE TO A SPECIFIC CHARECTER’S DYNAMIC PAGE…..

REST is a set of architectural constraints, not a protocol or a standard. API developers can implement REST in a variety of ways.
A REST API (also known as RESTful API) is an application programming interface (API or web API) that conforms to the constraints of REST architectural style and allows for interaction with RESTful web services. REST stands for representational state transfer.
You can think of an API as a mediator between the users or clients and the resources or web services they want to get. It’s also a way for an organization to share resources and information while maintaining security, control, and authentication.
 This information, or representation, is delivered in one of several formats via HTTP: JSON (Javascript Object Notation), HTML, XLT, Python, PHP, or plain text. JSON is the most generally popular file format to use because, despite its name, it’s language-agnostic, as well as readable by both humans and machines. 
Headers and parameters are also important in the HTTP methods of a RESTful API HTTP request, as they contain important identifier information as to the request's metadata, authorization, uniform resource identifier (URI), caching, cookies, and more. There are request headers and response headers, each with their own HTTP connection information and status codes.
Though the REST API has these criteria to conform to, it is still considered easier to use than a prescribed protocol like SOAP (Simple Object Access Protocol), which has specific requirements like XML messaging, and built-in security and transaction compliance that make it slower and heavier. 
In contrast, REST is a set of guidelines that can be implemented as needed, making REST APIs faster and more lightweight, with increased scalablity—perfect for Internet of Things (IoT) and mobile app development.
REST (Representational State Transfer) is an architectural style for designing web services that provides a set of constraints and principles to ensure that web services are scalable, reliable, and easily maintainable. RESTful APIs are APIs that follow these principles.
A RESTful API is a web service that uses HTTP requests to GET, PUT, POST, and DELETE data. The API is designed to be stateless, meaning that the server does not store any client data. Instead, each request contains all the necessary information for the server to process the request and return the appropriate response.
The key principles of RESTful API design include:
Resource identification: Each resource in the API should be identified with a unique URL.
Resource manipulation: The API should provide a set of standard HTTP methods (GET, PUT, POST, DELETE) to manipulate the resources.
Representation: The resources should be represented in a standard format, such as JSON or XML.
Statelessness: The server should not store any client state, and each request should contain all the necessary information for the server to process the request.
By following these principles, RESTful APIs provide a standardized and scalable way to access and manipulate resources over the web.




 Unlike Rest graphQl(continue with server) has one endpoint
underfetching and overfetching(rest overfetches)
graphQl tutorial Perdro Tech
(get mock data->
https://www.mockaroo.com/ mock data stexcel yev download json formatov` MOCK_DATA.json folder move to src
test data on online graphiql)




https://www.youtube.com/watch?v=yqWzCV0kU_c
(introdunction queries and schemas in https://countries.trevorblades.com/)
1.npm install apollo-server graphql
2.npm install nodemon -> putting the script in package json
"scripts": {
   "test": "echo \"Error: no test specified\" && exit 1",
   "start": "nodemon index.js"
 },
to start` npm start
3.in index.js`
(we will not use express-graphql, but we’ll use apollo server instead)
const { ApolloServer } = require("apollo-server");


const server = new ApolloServer({ typeDefs, resolvers });
// all types in typeDefs, all functions(that deal with the data) in resolvers
server.listen().then(()=>{
 console.log('server listening on')
})
(if we run now the nodemon will crash, because we didn’t create any types and resolvers)
4.creating a folder schema, inside of it files-> resolvers.js, type-defs.js
(the whole api is a graph and first level is the query type)(in order to create query for example user we should create a type users)
in type-defs.js`
const { gqk } = require("apollo-server");
// gql allows us to write pure graphql code and translate to smth that js undestands;


const typeDefs = gql`
   type User {
       name:String!
       username:String!
       age:Int!
       nationality:String!


   }
   type Query{
       users:[User!]!
   }


`
module.exports={typeDefs};
5.creating a folder fakeData.js
const UserList = [
 {
   id: 1,
   name: "John",
   username: "Johnny",
   age: 20,
   nationality: "Canada",
 },...
if we export like` export const userList=...... above we’re getting an error
we should export like this` module.exports={UserList};


6.resolvers.js`
const { UserList } = require("../fakeData");
const resolvers = {
 Query: {
   users() {
       return UserList;
   },
 },
};


module.exports={resolvers}
7. index.js will become`
const { ApolloServer } = require("apollo-server");
const {typeDefs}=require('./schema/type-defs');
const {resolvers}=require('./schema/resolvers');
const { UserList } = require("./fakeData");


const server = new ApolloServer({
 typeDefs, resolvers
});
// all types in typeDefs, all functions(that deal with the data) in resolvers


server.listen().then(({url})=>{
 console.log(`Your API is running at: ${url}:`);
})
and if we run the server`npm start and that open a browser in localhost 4000 we’ll see grapgql apollo pagewhere we can press the button and test our queries.
for example we write`
query GetMyAllUsers {
 users {
   id
   name
 }
}
and by pressing getmyallusers button on the right we’ll get out output (an array of users with the mentioned fields)
8.enums in graphql allows us to validate data easily. We can have an enum for nationality field here. because there is limited amount of natiofriends:[User]
nality, so someone not be able to include a nationality which doesn’t exist.
in type-devs.js inside gql`` below add 
enum Nationality {
   ARMENIA
   SPAIN
   RUSSIA
   USA
   UGANDA
   CANADA
 }
and chagne in type User{
nationality:Nationality
}
It is best practice to write enums in capital letters so we should change the countries to capital letters in fake data to, so they could match/
9. add a friends field in Type user	
…
friends:[User] not mandatory(!)
add some friends to a concrete user in the fake data`
….
friends: [
     {
       id: 2,
       name: "Joanna",
       username: "Joann",
       age: 70,
       nationality: "SPAIN",
     },
     {
       id: 5,
       name: "Jim",
       username: "Jimmy",
       age: 32,
       nationality: "UGANDA",
     },
   ],
which will output in
in type Query add a concrete user query field
10.npm install lodash --save
11.in type-defs.js`
add user`
type Query {
   users: [User!]!
   user(id: ID!):User!
 }
 in resolvers`
const _ = require("lodash")
const resolvers = {
 Query: {
   users: ()=> {
       return UserList;
   },
   user:(parent, args)=>{
       const id=args.id;
       const user=_.find(UserList, {id:number(id)})  //or just {id}
       return user;
   }
 },
};
12.query to test` (we can test in localhost/4000 by clicking the test your query button)
query GetAUser($UserId:ID!){
  user(id:$UserId){
    name
    age
    nationality
    friends{
      name
    }
  }
}
below we need to provide variable UserId
{
 "UserId": 4
}


13.now we want to create type movie which actually is not related to users. In type-defs.js`


type Movie{
 id:ID!
 name:String!
 yearOfPublication:Int!
 isInTheaters:Boolean!
 }
 type Query {
   users: [User!]!
   user(id: ID!):User!
   movies:[Movie!]!
   movie(name:String!):Movie!
 }
fakeData.js`
const MovieList = [
 {
   id: 1,
   name: "Avengers",
   yearOfPublication: 2019,
   isInTheaters: true,
 },
resolver.js`
   //movie resolvers
   movies:()=>{
       return MovieList;
   },
   movie:(parent, args)=>{
       const name=args.name;
       const movie = _.find(MovieList, {name:name})//or just {name}
       return movie;
   }
test query`
1.get list of movies
query GetMovies{
 movies {
   name
 yearOfPublication
 }
}
2.get single movie
query GetMovie($name:String!) {
 movie(name:$name){
 id
 yearOfPublication
 }
}
14. now we want to add a data about favorite movies to the users data(not to particular users data, but to join datas)add to type User in type-defs`
type User {
  …….
   favoriteMovies:[Movie]
 }




15in resolvers.js`
after Query:{
…
},
 User: {
   favoriteMovies: () => {
       return _.filter(MovieList, (movie)=>
           movie.yearOfPublication > 2000 && movie.yearOfPublication<=2010
       )
   },
 },
test query
1.query GetMovie($movieName:String!){
 movie(name:$movieName){
   yearOfPublication
 }
 }
2.query GetAllMovies{
 movies{
   name
   yearOfPublication
 }
}


3.query GetUser($userId:ID!) {
 user(id:$userId){
 id
 name
 age
 nationality
 friends{
   name
   age
 }
 favoriteMovies {
   name
 }
 }
}
below variables`
{
 "userId": 1
}
Graphql mutations


a)
now our user doesn’t have favorite movies field.For HTTP mutation will be with post, put and delete methods.
1.In tipe-defs.js`
 input CreateUserInput{
   name: String!
   username: String!
   age: Int!                     
   nationality: Nationality=ARMENIA
 }
 type Mutation{
 createUser(input:CreateUserInput!):User! //veradardz User partadir ! nshany hanum enq` test mutation anelu hamar, heto kdnenq
 }


2.in resolvers.js`
 Mutation:{
   createUser:(parent, args)=>{
     const user= args.input;
console.log(user)
   }
 }


3. test mutation
mutation CreateAUser($createUserInput: CreateUserInput!){
 stex createUser henc grum enq avtomat beruma` 
}
mutation CreateAUser($createUserInput: CreateUserInput!){
 createUser(input: $createUserInput) {
   id
   name
   age
 }
}




below we should pass a data as a variable`
{
"createUserInput":{
 "name":"Pedro",
 "username":"PedroBoy",
 "age":20
}
}
response-y talisa` 
{
 "data": {
   "createUser": null
 }
}
bayc resolvers.js-um drac consolov terminalum bermuda mer datan`
{
  name: 'Pedro',
  username: 'PedroBoy',
  age: 20,
  nationality: 'ARMENIA'
}
3.So to push the actual data in resolvers.js	
get last id`
Mutation:{
   createUser:(parent, args)=>{
     const user= args.input;
     const lastId=UserList[UserList.length-1].id;
     user.id=lastId+1;
     UserList.push(user);
     return user;
   }
 }


test` arden responsum cuyca talis
u ete test get all users anenq avelacac ktesnenq
than we should insert to database


b)update user
1.type-defs`
type Mutation{
 createUser(input:CreateUserInput!):User
 updateUsername(input:UpdateUsernameInput!):User
 }
 enum


2.resolvers-um mutationi mej avelacnum enq`


   updateUsername:(parent, args)=>{
     const {id, newUsername} = args.input;
     let userUpdated;
     UserList.forEach((user)=>{
       if(user.id === Number(id)){
         user.username=newUsername;
         userUpdated=user;
       }
     });
     // console.log(userUpdated)
     return userUpdated;
   }


test`
mutation UpdateAUser($updateUsernameInput: UpdateUsernameInput!){
 updateUsername(input: $updateUsernameInput) {
   id
   username
 }
}
below`
{
 "updateUsernameInput": {
   "id": "5",
   "newUsername": "newPedro"
 }
}
c) delete user


type-defs`
type Mutation{
 createUser(input:CreateUserInput!):User
 updateUsername(input:UpdateUsernameInput!):User
 deleteUser(id:ID!):User  //add this line to mutation
 }


resolvers`
deleteUser:(parent, args)=>{
     const id=args.id;
     _.remove(UserList, (user)=>user.id===Number(id));
     return null;
   }


test in localhost/4000`
mutation($deleteUserId: ID!) {
 deleteUser(id: $deleteUserId) {
   id
 }
}


below`
{
 "deleteUserId":"1"
}
heto obshi cucakim et id-ov usery chka.
Now creating client folder for font end


1.terminal cd .., mkdir client, cd client
2.npx create-react-app .     (. means inside the folder no need to write a name for the folder)
https://www.apollographql.com/docs/react/get-started
npm install @apollo/client graphql
fetch the data of all users in client side`
for this we need to connect graphql in our highest level component` app.js


import {ApolloClient, InMemoryCache, ApolloProvider} from '@apollo/client'
ApolloClient-> class to use this to connect Api


apollo client has a very good state management which allows to catch data, making a request every time by moving from one component to another can be overkilling thats why we cache the data. inmemory catche catches the data in memory.


const client = new ApolloClient({
   cache:InMemoryCache,
   uri: "https://localhost:4000/graphql"
 })


and we should wrap the whole component to apollo provider in app.js
<ApolloProvider client={client}>
     <div className="App">
       <h4>list of users</h4>
     </div>
   </ApolloProvider>
import also useQuery hook above`
import { ApolloClient, InMemoryCache, ApolloProvider, useQuery } from "@apollo/client";
there is also a useMutation, useLasy hooks…
or create separate component for displaying users` and import useQuery.


import React from "react";
import { useQuery, gql } from "@apollo/client";


const QUERY_ALL_USERS = gql`
 query GetAllUsers {
   users {
     id
     name
     age
     username
     nationality
   }
 }
`;
export const DisplayUsers = () => {
 const { data, loading, error } = useQuery(QUERY_ALL_USERS);
 if (error) {
   console.log(error);
   return <h1>error..</h1>;
 }
 if (data) {
   console.log(data);
 }
 if (loading) {
   return <h1>Loading...</h1>;
 }
 return (
   <div>
     {data &&
       data.users.map((item) => (
         <div>
           <div>name:{item.name}</div>
           <div>username:{item.username}</div>
           <div>age:{item.age}</div>
           <div>nationality:{item.nationality}</div>
         </div>
       ))}
   </div>
 );
};


if we want to do another query in the same component, we cant just write again like`
const { data, loading, error } = useQuery(QUERY_ALL_MOVIES);


cos we have already the variables data, error, loading. we can do like`
const {data:movieData, loading:movieLoading, error:movieError}=...
or`
const movieData = useQuery(QUERY_ALL_MOVIES);
and then grab`
if (movieData.error) {
   console.log(error);
   return <h1>error movie..</h1>;
 }
 if (movieData.data) {
   console.log("data movie:", movieData.data);
 }
 if (movieData.loading) {
   return <h1>Loading movie...</h1>;
 }


and map`
if (movieData.error) {
   console.log(error);
   return <h1>error movie..</h1>;
 }
 if (movieData.data) {
   console.log("data movie:", movieData.data);
 }
 if (movieData.loading) {
   return <h1>Loading movie...</h1>;
 }

query by id, individually
import useLazyQuery  hook from apollo client
import React, { useState } from "react";
import { useLazyQuery, gql } from "@apollo/client";


export const GetIndividualData = () => {6
 const GET_MOVIE_BY_NAME = gql`
   query Movie($name: String!) {
     movie(name: $name) {
       name
       yearOfPublication
     }
   }
 `;
 const [movieSearched, setMovieSearched] = useState("");
 const [fetchMovie, { data: movieSearchData, error: movieError }] =
   useLazyQuery(GET_MOVIE_BY_NAME);


 return (
   <div>
     <h2>Get Individual data</h2>
     GetIndividualData
     <input
       type="text"
       placeholder="movie name..."
       onChange={(event) => {
         setMovieSearched(event.target.value);
       }}
     />
     <button
       onClick={() =>
         fetchMovie({
           variables: {
             name: movieSearched,
           },
         })
       }
     >
       Get movie data
     </button>
     {movieSearchData && (
       <div>
         <h1>Movie name:{movieSearchData.movie.name}</h1>
         <h1>Year of publication:{movieSearchData.movie.yearOfPublication}</h1>
       </div>
     )}
     {movieError && (<div>error...</div>)}
   </div>
 );
};



Mutations from client side

 crea
_______________________________________________





react typescript
________________________________________
1.npx create-react-app typecsript-tutorial --template typescript
1.const array: string[] = [];         2.const array: (string | number)[] = [];  //1.array of strings 2. array of strings and numbers
kam nuyny`
const array: Array<string | number> = [];
touple`
let arr:[string, number]=[‘ko’, 1], isk [1, 2]-sxal

let arr: string[]=["ko", "koko"];

let objCorrect: ObjectCorrect = { name: "correct", age: 22 };


type ObjectCorrect = {
  name: string;
  age?: number;
}; //optional
typescript documentation
https://www.typescriptlang.org/docs/handbook/2/everyday-types.html
for function`
  const getName = (name: string)=> {
    if (name === "Pedro") {
      return 25;
    } else {
      return 0;
    }
  };
  const getName = (name: string):number => {
    if (name === "Pedro") {
      return 25;
    } else {
      return 0;
    }
  };
argumentic heto returni typen e cuyc talis, vory kareli e chgrel, ete vochinch chi veradardznum` :void 

for components`
import React, { FC } from "react";
const App: FC = () => {
…` chnayac aranc dra el ashxatuma
for component props`

interface IProps={
name:string,
age?:number,                              //optional` componenti het cnoxic kareli e chpoxancel
getName:(name:string)=>string //inch e veradardznum or :void` vochinch

export const someComponent=(props:IProps)=>{
}
we can also destructure`
export const someComponent=({name, age, getName}:IProps)=>{
}
another variant` 
export const someComponent:FC<IProps>=({name, age, getNam})=>{}
—---------------

for useState`
 const [country, setCountry] = useState<string | null>("");
  <input
        type="text"
        placeholder="write down your country..."
        onChange={(e) => {
          setCountry(e.target.value);
        }}
      />

kashxati, bayc ete function inline chgrenq` ajl handleChange hanenq durs` chi haskana eventy inch type a, dra hamar inline grum enq u hoveri jamanak type copy anum, heto hanum handlchange-i argumentin talis typey.`
  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setCountry(e.target.value)
  };
ChangeEvent petqa import anel verevum, inchpes FC-n
changeEventy import arec verevum, baic im mot aranc dra ashxatec.

Enums and types
if we have many options
in interface we have some sort of object, thats the difference.
in enum a set of different options.


  enum hairColor {
    blond = "wow it so cool color",
    black = "thats classic!",
    pink = "so unique!",
  }


avelacnum enq Iprops-i mej`
….
hairColor:hairColor
cnox componentum importum enq enum hairColory yev poxancum childin vorpes props.
if we dont have so many options, but just want to create variable, for example`
const someName=”Pedro” or “John”
 type SomeNameType = "Pedro" | "John";
  const someName: SomeNameType = "Pedro";


_____________________________________________________________

How does updates work in React?
On the first load, ReactDOM.render() will create the Virtual DOM tree and real DOM tree.
React compares Virtual DOM with real DOM and updates real DOM. This process is called Reconciliation. React uses Diffing algorithm techniques of Reconciliation.
Updated real DOM is repainted on the browser.
Virtual DOM is pure JS file and light weight, So capturing any update in Virtual DOM is much faster than directly updating on Real DOM.
React takes a few milliseconds before reconciliation. 
Reconciliation
React compares the Virtual DOM with Real DOM. It finds out the changed nodes and updates only the changed nodes in Real DOM leaving the rest nodes as it is. This process is called Reconciliation.


Socket (Socket.IO)
is a real time bidirectional library,(between a client and a server) which allows you to mainly(not only) use websockets. It is built on top of the WebSocket protocol and provides additional guarantees like fallback to HTTP long-polling or automatic reconnection. For this we need node.js with express.

Terminal one step up`
1.cd ..   (space between cd and ..)
mkdir name-directory
————————
Socket iO
Creating server
App-name has two directories—1. client(where we npx create-react-app…..), 2.server 
In server folder in terminal
npm init -y(package.json is created in server folder)
npm install express (Fast, unopinionated, minimalist web framework for Node.js)
npm install cors(CORS stands for Cross-Origin Resource Sharing . It allows us to relax the security applied to an API. )
npm install nodemon (restarts server every time we make changes, nodemon is a tool that helps develop node. js based applications by automatically restarting the node application when file changes in the directory are detected.)
npm install socket.io  
kam bolory miangamic npm install express cors nodemon socket.io 
Index.js-um`
  const express = require('express');
const app = express();
const http = require('http');
const {Server} = require('socket.io');  //class
const cors = require('cors');
app.use(cors());

const server = http.createServer(app);
const io = new Server(server, {
    cors:{
        origin:"http://localhost:3000",
        methods: ["GET", "POST"],
    },
});
server.listen(3001, ()=>{
    console.log('Server listening');
})
Package.json-um avelacnum enq`
  "scripts": {
    "start": "nodemon index.js"
  },
Yndhanur `
{
  "name": "server",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "keywords": [],
  "author": "",
  "license": "ISC",
  "scripts": {
    "start": "nodemon index.js"
  },
  "dependencies": {
    "cors": "^2.8.5",
    "express": "^4.17.3",
    "nodemon": "^2.0.15",
    "socket.io": "^4.4.1"
  }
}

Hima ete npm start anenq- Kberi server is listening
Client folder-um, vor komponenti mej vor uzum enq kanchel` onClick-ic uzum enq emit() funkcian kanchel, bayc ayn. Chka frontum, dra hamar piti client foldery gnanq terminalov u 
npm install socket.io-client
Setting up the connection
Serveri papkayı mej `  
io.on('connection', (socket)=>{
 console.log(`user connected: ${socket.id}`);
})
Npm start vor anenq, user connected Keri inch vor idnerov tesminalum(amen anger page front refreshanelis et anhayt userneri tivy avelanuma, vorovhetev chenq nshel stanalu dzevy) console logy kashxati

Frontum`
terminal -> cd client
npx-create-react-app . (henc folderum)
npm i socket.io-client (to connect to socket)
import React from 'react';
import io from 'socket.io-client';


const socket =io.connect("http://localhost:3001")


export const SocketIo = () => {
   const sendMessage = () =>{
       socket.emit('send_messsage', {message:'hello server'})
  
   }
 return (
   <div>
       <h3>Secket IO</h3>
       <div>
           <input type='text' placeholder='Message...' />
           <button onClick={sendMessage}>Send Message</button>
       </div>
   </div>
 )
}
backend-um`
io.on('connection', (socket)=>{
//  console.log(`user connected: ${socket.id}`);
socket.on('send_message', (data)=>{
   console.log(data)
})
})
if we press button, message will be sent and appear in terminal console.log

now we want to send this message to everyone who is connected to the server. (in frontend we’ll receive)
frontum`
import React, { useEffect, useState } from "react";
import io from "socket.io-client";


const socket = io.connect("http://localhost:3001");


export const SocketIo = () => {
   const [messageState, setMessage]=useState('');
   const [messageReceived, setMessageReceived]=useState('');


 const sendMessage = () => {
   socket.emit("send_message", { message: messageState });
 };
 useEffect(() => {
   socket.on("receive_message", (data) => {
   //   alert(data.message);
     setMessageReceived(data.message);
   });
 }, [socket]);
 return (
   <div>
     <h3>Secket IO</h3>
     <div>
       <input type="text" placeholder="Message..." onChange={(event)=>{setMessage(event.target.value)}} />
       <button onClick={sendMessage}>Send Message</button>
       {/* <div>display message: {messageState}</div> */}
       <h3>received message: {messageReceived}</h3>
     </div>
   </div>
 );
};
now if we click the button out previous message` hello server will be sent to server and received as an alert
(we should open another browser lith localhost 3000 and pressing the button one one we will receive that message in another browser)
—--------------------------------------------------------------------------------------
Chat(socket.io, react, express)
client folder
server folder
install all the dependencies as above
Client->app.js`
import "./App.css";
import io from "socket.io-client";
import { useState } from "react";
import { Chat } from "./chat";


const socket = io.connect("http://localhost:3001");


function App() {
 const [userName, setUserName] = useState("");
 const [room, setRoom] = useState("");
 const [showChat, setShowChat] = useState(false);


 const joinRoom = () => {
   if (userName !== "" && room !== "") {
     socket.emit("join_room", room);
     setShowChat(true);
   }
 };
 return (
   <div className="App">
     {!showChat ? (
       <div className="joinChatContainer">
         <h3>Join chat</h3>
         <input
           type="text"
           placeholder="Enter your name..."
           onChange={(e) => {
             setUserName(e.target.value);
           }}
         />
         <input
           type="text"
           placeholder="Enter room id"
           onChange={(e) => setRoom(e.target.value)}
         />
         <button onClick={joinRoom}>Join the room</button>
       </div>
     ) : (
       <Chat socket={socket} username={userName} room={room} />
     )}
   </div>
 );
}


export default App;

client->chat.js
import React, { useState, useEffect } from "react";


export const Chat = ({ socket, room, username }) => {
 const [currentMessage, setCurrentMessage] = useState("");
 const [messageList, setMessageList] = useState([]);


 const sendMessage = async () => {
   if (currentMessage !== "") {
     const messageData = {
       room: room,
       author: username,
       message: currentMessage,
       time:
         new Date(Date.now()).getHours() +
         ":" +
         new Date(Date.now()).getMinutes(),
     };
     await socket.emit("send_message", messageData);
     setMessageList((list) => [...list, messageData]);
   }
 };
 useEffect(() => {
   socket.on("receive_message", (data) => {
     setMessageList((list) => [...list, data]);
   });
 }, [socket]);


 return (
   <div className="chat-window">
     <div className="chat-header">
       <p>live chat</p>
     </div>
     <div className="chat-body">
       {messageList.map((item, ind) => (
         <div
           className="message"
           id={username === item.author ? "your" : "other"}
           key={ind}
         >
           <div>
             <div className="message-content">
               <p>{item.message}</p>
             </div>
             <div className="message-meta">
               <p id="author">{item.author}</p>
               <p id="time">{item.time}</p>
             </div>
           </div>
         </div>
       ))}
     </div>
     <div className="chat-footer">
       <input
         placeholder="Hey..."
         onChange={(e) => setCurrentMessage(e.target.value)}
         onKeyPress={(e) => {
           // if (e.key === "Enter") {
           //   e.preventDefault();
           //   sendMessage();
           // }
           e.key==="Enter" && sendMessage();
         }}
       />
       <button onClick={sendMessage} className={currentMessage.length>0?'active':''}>&#9658;</button>
     </div>
   </div>
 );
};

server->index.js
const express=require('express');
const app = express();
const http = require('http');
const cors = require('cors');
const {Server}= require("socket.io")
app.use(cors());




const server = http.createServer(app);


const io = new Server(server, {
   cors:{
       origin:"http://localhost:3000",
       methods:["Get", "POST"],
   }
})
io.on('connection', (socket) =>{
   console.log(`user connected ${socket.id}`);
   socket.on('disconnect', ()=>{
       console.log("user disconnected", socket.id)
   })
   socket.on("join_room", (data)=>{
       socket.join(data);
       console.log(`User with id ${socket.id} joined room: ${data}`)
   })
   socket.on("send_message", (data)=>{
       console.log('received message', data);
       socket.to(data.room).emit("receive_message" ,data)
   })
});


server.listen(3001, ()=>{
   console.log("Server listening")
})
also if we want to scroll down to the bottom` we should install->
npm install react-scroll-to-bottom

and input to chat.js, than wrap the map of chat-body by it
import ScrollToBottom from "react-scroll-to-bottom";
<ScrollToBottom>
{messageList.map….
</ScrollToBottom>
 and to delete the input value after sending the message ` value={currentMessage}
and in the function of send message setCurrentMessage(‘’);

React icons(only imports an icon not a whole library)
from https://react-icons.github.io/react-icons/

https://www.youtube.com/watch?v=aor9hlcODUE
npm install react-icons
faylum` import { FaBars } from "react-icons/fa";->vorovhetev font awesome bereci/petq e nshvi
 u componenti pes`<FaBars />
to style the icon <FaBars size=’2em’/> by default the size is 1em and we can ad color
   <FaBars size="2em" color="red" />
we can also add a style what we want` style={..}
if we want to tha all icons same style` import {IconContext} from “react-icon”
and wrap the app or the main parent component inside 
<IconContext.Provider>.....</IconContext.Provider>
—------------------------------------------------------------------------------------------



MOngo DB

https://www.youtube.com/watch?v=DZBGEVgL2eE
my cloud https://cloud.mongodb.com/v2/6261212297c70d10ab735cd5#clusters
accessList
download by link-> https://www.youtube.com/watch?v=6_NSkDRXPZk
https://www.mongodb.com/try/download/community
download mongodb shell 
https://www.mongodb.com/try/download/shell
cmd C:\Users\USER>mongosh --version
bermuda->
1.3.1

cmd-um mongosh grelis, bermuda informacian
verjun
test>

test> show dbs
admin     41 kB
config  73.7 kB
local   73.7 kB

https://cloud.mongodb.com/v2/6261212297c70d10ab735cd5#clusters/connect?clusterId=Cluster0 (connect to my cluster)
copy the link after choosing i have mongo shell installed
mongosh "mongodb+srv://cluster0.rntnu.mongodb.net/myFirstDatabase" --apiVersion 1 --username Armine
 cmd passwords uzum type->22053030
->db
tpuma myFirstDatabase
->show dbs
bolorna cuyc talis
admin   287 kB
local  1.35 GB
bayc myFirstDb-n cuyc chi talis. minchev mi ban insert chanenq chi hamarum stexcvac
-> use ongridtask -> nor db (ham el switch a anum depi et db-n ete ayn arden ka)
-> db.createCollection("users") db-um “table” a stexcum
kam miangamis e2e grenq` kstexci
->  db.users.insertOne({"name":"John", "email":"jonh2022@gmail.com", "password":"john2022", "score":"2"})                 

->db.users.insertMany([{"name":"John", "email":"jonh2022@gmail.com", "password":"john2022", "score":"2", {....}[)
-> db.users.find() -> beruma bolory
->db.users.find({"score":{$gt:3}})
->db.users.find({"name":"Pol"})
UPDATE
-> db.users.updateOne({ name: "Pol" }, { $set: {age:22}})
->
db.products.updateOne(
  { _id: 100 },
  { $set:
     {
       quantity: 500,
       details: { model: "2600", make: "Fashionaires" },
       tags: [ "coats", "outerwear", "clothing" ]
     }
  }
)
-> to be continued……… se link` 
______________________________________________________
to connect to a mongodb from local terminal type mongo
(if it cant find the mongo command, set the environmental variable C:\Program Files\MongoDB\Server\5.0\bin by editing and pressin new in system preferences popup)
so when i type mongo it brings a large text in cmd
than ->db
it puts you on test
db.adminCommand({listDatabases:1})
(bayc eli chberec mongoi kayqiny:((()
then exit
clear
_______________________________________________________
https://www.youtube.com/watch?v=DZBGEVgL2eE







Protected routes(public and private routes)
1 easy variant->
app`
<ul>
      <NavLink to="/"><li>Sign in</li></NavLink>
      <NavLink to="home"><li>Home</li></NavLink> 
      <NavLink to="account"><li>Account</li></NavLink> 
</ul> 
    <Routes>
       <Route path="/" element={<SignIn />}/>
       <Route element={<ProtectedRoutes2/>}>
        <Route path="/account" element={<Account />}/>
        <Route path="/home" element={<Home />}/>
       </Route>
      </Routes> */}


Protecterroutes.js-um`
import { Outlet, Navigate } from "react-router";
import SignIn from "./SignIn";


const useAuth = () => {
  const user = { loggedIn: true };
  return user && user.loggedIn;
};
const ProtectedRoutes2 = () => {
  const isAuth = useAuth();
  // return isAuth ? <Outlet /> : <SignIn />;   one way
  return isAuth ? <Outlet /> : <Navigate to="/" />;
};
export default ProtectedRoutes2;


create a simple rest api in node
1.npm init -y
2.npm i express
3.const app = require("express")(); //initialize
heto dardznel` 
const express = require("express");
const app = express();


const PORT = 8080;
app.use(express.json()); //middleware to parse the request




app.listen(PORT, () => console.log(`my server listent the port ${PORT}`));

terminal ->node .
(console.log-y cuyca talis message-y)
isk ete bacen localhost:8080->Cannot GET /   ->cuyca talis, isk inspect-ov networkum cuyca talis error 404.
4.to access api we can use.
-curl from command line
-vs extension
-or rest client like insomnia or postman
we are going to use insomnia
download insomnia https://insomnia.rest/download
5.//make an endpoint (the second argument runs this function when route is requested)
// the function itself has 2 arguments(req, res) (incoming and outgoing data)
// get http://localhost:8080/tshirt
app.get("/tshirt", (req, res) => {
  res.status(200).send({
    tshirt: "shirt one",
    size: "large",
  });
});
//by default the data sent back is in json format

we.ll get the response in insomnia writing the url beside get` http://localhost:8080/tshirt

{
	"tshirt": "shirt one",
	"size": "large"
}
post tshirt–
app.post("/tshirt/:id", (req, res) => {
  const { id } = req.params;
  const { logo } = req.body;
  if (!logo) {
    res.status(418).send({ message: "we need a logo" });
  }
  res.send({
    tshirt: `tshirt with logo: ${logo} and ID of ${id}`,
  });
});

insomnia`
post http://localhost:8080/tshirt/3

{
	"logo":"Fire"
}

https://www.youtube.com/watch?v=oNlMrpnUSFE  see for api pedro tech
HOOKS


useMemo: Returns and stores the calculated value of a function in a variable
useCallBack: Returns and stores the actual function itself in a variable

webpack->
If we dont do CRA, we just have empty folder to initialize the project and create package.json file ->npm init, then fill in name, version description, entry point(index.js) by default
2.npm install webpack - - save dev (same as web dependency)-> this throws error in my comp, this is error is windows typical. npm install webpack chokidar --save-dev worked. Node_modules folder appears, but not as big as in CRA.
Now if we create 2 files script1.js, script2.js inside one 
const message=”something” does not fork.



OOP JS (net ninja)

OOP stands for Object-Oriented Programming, which is a programming paradigm that focuses on using objects to represent data and the operations that can be performed on that data. JavaScript is a multi-paradigm language, which means that it supports multiple programming paradigms, including OOP.
In JavaScript, OOP is implemented using objects, classes, and inheritance. An object is a collection of properties and methods that are used to represent a particular entity or concept. A class is a blueprint for creating objects, which defines the properties and methods that all objects of that class will have. Inheritance is the mechanism by which objects can inherit properties and methods from their parent class.
JavaScript provides several ways to implement OOP, including using constructor functions, object literals, and classes. Constructor functions are functions that are used to create objects, and they define the properties and methods of the object using the "this" keyword. Object literals are a shorthand way of creating objects, where you define the properties and methods directly in the object literal notation. Classes, introduced in ES6, provide a more structured way of creating objects, using the "class" keyword to define a template for objects, and the "constructor" method to initialize the object properties.
Overall, OOP in JavaScript provides a way to write more modular, reusable, and organized code, by encapsulating data and behavior in objects and classe
Functional components in React are typically used to implement a functional programming paradigm rather than an object-oriented programming (OOP) paradigm. However, functional components in React can still incorporate OOP concepts, such as encapsulation and inheritance, through the use of certain techniques.
One way to implement encapsulation in functional components is by using closures
Everything in js are objects. Objs are quite like real life objects. Like cars….which has props(color brend) and methods(can run, stop ets). Arr-s are obs, coz they have methods like length, sort, map……
There are several build in objects like window gl. Obj.Parent ob all objs.with its different methods like innerwidth..exept primitives. But strings have also methods and props  like split, or length prop, they become onb behind the scenes when we try to access a method. When creatin str line=new String(“kk’) it is already an object.	
Encapsulation: instead of saving different values, like name, tel., and functions, we center them in a single variable. This process is called  encapsulation. Const user={name:’John’, email:’sh@hx.com’, login(){console.log(‘xnxn)}}....
What is we have more than 1 user, we cant create an object for each user, this is why es6 new feature class becomes useful. Under the hoo classes are just doing the same thing as prototypes .
Class is a template, blueprint for an obj.
Class is created without const, just class User//with capital letter
First we should define the constructor function, which creates class

class User={
constructor(email, name){
this.email=email,
this.name=name
}
}
Now if we create out  1user
Const user1=new User()
The new keyword creates a new empty object, sets the value of  ‘this’ to the empty obj, anc calls the constructor func.
const user1=new User(‘john’ email@cj.com)
Now we want to add to the class method, we dont add methods into constructor

class User={
constructor(email, name){
this.email=email,
this.name=name
}
login(){
console.log(this.email, ‘just logged in’)
}
logout(){
console.log(this.email, ‘just logged out)
}
}
And call user1.login().
Then user2.logOut

Method chining
We can chain different methods
 user1.login().logout() -> will return erro: test2.html:26 Uncaught TypeError: Cannot read properties of undefined (reading 'logout')().logout();
To solve the issue we should return this inside the method
login(){
console.log(this.email, ‘just logged in’);
return this
}


In addition to encapsulation and inheritance, there are several other typical concepts that classes have:

1. Polymorphism: This refers to the ability of objects to take on multiple forms. In object-oriented programming, polymorphism is usually implemented through inheritance and method overriding.

2. Abstraction: This is the process of simplifying complex systems by breaking them down into smaller, more manageable pieces. In classes, abstraction is often implemented through the use of interfaces and abstract classes.

3. Composition: This is the process of combining simpler objects to create more complex ones. In classes, composition is often implemented through the use of member variables that are instances of other classes.

4. Access modifiers: These are keywords that control the visibility and accessibility of class members. The most common access modifiers are public, private, and protected.

5. Constructors and destructors: Constructors are special methods that are called when an object is created, and they are used to initialize the object's state. Destructors are special methods that are called when an object is destroyed, and they are used to clean up any resources that the object was using.

6. Method overloading and overriding: Method overloading is the process of defining multiple methods with the same name but different parameters. Method overriding is the process of redefining a method in a subclass that was already defined in the superclass.

7. Static members: These are class members that belong to the class itself rather than to any individual object of the class. Static members are typically used for constants or utility methods that don't require any state.
8.Inheritance is a key concept in object-oriented programming (OOP) that allows you to create new classes based on existing classes. We archive with extend keyword;
With our users class example, if we wand to add functionality for admin, which is a different type of a user, we can 
let users = [user1, user2];


      class Admin extends User {
        deleteUser(user) {
          users = users.filter((u) => u.email !== user.email);
        }
      }


      const admin1 = new Admin("adminName", "adminEmail");
      admin1.deleteUser(user1);
      console.log({ users });

JS classes that es6 introduced is a syntactic sugar upon prototypal inheritance, abstraction opon prototype, are pretended classes.
We could just have function instead of class to do the same 
  function User(name, email) {
        this.name = name;
        this.email = email;


        this.login = function () {
          console.log("logged in");
          return this;
        };
      }
      const user1 = new User("john", "john@emai.com");
      const user2 = new User("john2", "john2@emai.com");
      console.log(user1.login());
This function is constructor function
Every obj type has is prototype property (data array obj) and we can access the concrete method or prop through .prototype
In JavaScript, a prototype is an object that is associated with every object and constructor function. The prototype object contains properties and methods that are shared among all instances of the object or constructor function.
When you create an object or constructor function, a prototype object is automatically created and associated with it. You can add properties and methods to the prototype object using the prototype property. When an instance of the object or constructor function is created, it inherits the properties and methods of the prototype object.
Here's an example of creating a constructor function and adding properties to its prototype:
function Person(name, age) { this.name = name; this.age = age; } Person.prototype.greet = function() { 
console.log(`Hello, my name is ${this.name} and I am ${this.age} years old.`); } 

let person1 = new Person('John', 30); 
person1.greet(); // output: Hello, my name i+s John and I am 30 years old.
//we could just do
 function Person(name, age) {
        this.name = name;
        this.age = age;
        this.greet = function () {
          console.log(
            `Hello, my name is ${this.name} and I am ${this.age} years old.`
          );
        };
      }

In this example, we create a constructor function Person with name and age properties. We then add a greet() method to the Person.prototype object. When we create an instance of the Person object using the new keyword, the instance inherits the greet() method from the prototype object. We can then call the greet() method on the instance to output a message.
Prototypes are an important concept in JavaScript because they allow us to create objects and constructor functions that share properties and methods, which can help to reduce code duplication and make our code more efficient.




NODE JS EUNICA (express, mongoDB)

companies like  Netflix, uber, payPal, eBay started using nodeJS
Node.js is an open-source, cross-platform, server-side runtime environment that allows developers to run JavaScript code outside of a web browser. It was initially released in 2009 and has since become a popular platform for building fast, scalable, and efficient network applications.
Node.js is built on top of the V8 JavaScript engine from Google, which is the same engine that powers the Chrome browser. it is single threaded
both Node.js and client-side JavaScript run on the same JavaScript runtime, which is typically provided by a web browser or the V8 engine in the case of Node.js. 
In addition, the global scope in Node.js is different from the global scope in a web browser. In a web browser, the global scope is typically the window object, while in Node.js, it is the global object. 
PROS
- It provides an event-driven, non-blocking I/O model that 
-allows developers to build highly scalable(below) and performant(fast, effective) applications. Node.js uses an asynchronous programming model, which means that it can handle many requests at the same time without blocking other requests.
-using JS across the entire stack makes faster and efficient development
-open-source packages available
-Very active community.
Scalability refers to a system's ability to handle increasing amounts of work or traffic without sacrificing performance or availability. When we say that Node.js is scalable, we mean that it can handle large and complex applications, and it can do so by efficiently utilizing system resources.

Node has built-in modules in it, for example reading files. meaning has additional functionality for example FS for reading files(const fs=require(‘fs’)).that with pure js we dont have this fuvtionality(we can with fetch()or FileReader API,(modern ways)or XMLHttpRequest).
where to use?
-API with database behind it(preferably NoSQL)
-Data streaming(think youtube)
-Real-time chat application
-Server-side web app(While a server-side rendered web application is a type of server-side web application, not all server-side web applications are server-side rendered. In fact, many server-side web applications use techniques such as AJAX (Asynchronous JavaScript and XML) to generate dynamic content on the client side without requiring a full page refresh.)
DONT USE node js with->
-apps with heavy server-side processing(CPU-intensive)like many heavy image manipulations, video conversion, file comperession(in this case ruby, php, pyton)

we can write code right in the terminal writing node  press enter, and if we want to exit node mode .exit or ctrl+D
By clicking tab keyword all the commands will be shown
By writing _ will give us previous result.
by writing String.+tab will bing us all the methods and properties for string.Same for Object.
By writing “clear” we go to a new line 
cntrl+L clears terminal
Cntrl C new line

now if we create a file index.js 
const hello = "hi world!";
console.log(hello);
by writing in terminal node we will just go again to terminal node js

reading file
const fs = require("fs");
const readFileResult = fs.readFileSync("./test.txt", "utf-8"); -> if we dont specify utf, we’ll get something buffer
by logging the readFileResult we’ll get the text of the file
(this is synchronous way, each line waits the previous line to be completer, this is a blocking way, but if we wrote just readFile…this would work asynchronous, same for writeFileSync) but now we should pass a callback, to wait for a response in order to show it on the console	
fs.readFile("./test.txt", "utf-8", (err, data)=>{console.log(data),})in case of readfile this callback is async, but in general, callback are not necessarily async


writing file
const newText = `some added text \n ${readFileResult}`;
fs.writeFileSync("./test.txt", newText);
writeFile("./test.txt", newText, err=>{}) //this is async

why does node js use so many callbacks?
(An asynchronous callback function is one that is not executed immediately when it is called, but is scheduled to run at a later time. Asynchronous callbacks are often used with asynchronous operations such as reading or writing files, making network requests, or handling events. callback can also be synchronous, it executes  immediately when it  is called)for example if we have many users using this app simultaneously, and one of them is trying to read a large file, the other users shouldn’t wait(while for example trying to login) until this user gets the data(because JS has a single thread). as soon as file reading is completed it is put to the thread.(in php for every user a single thread is created) 
What if we have multiple readFile callbacks, where each one nested into a previous one and depends on it? this is callback hell… the solution is using promises, or async/await


CREATING A SERVER

2 things to do` 
1. build a server
const http =require(‘http’) //gives network capability
const server = http.createServer((req, res) => {
  res.send("hello from the server");
});

2.listen to the server
//first arg is the port, which is a subadress on a sertain host , 2 arg address of the local host, optional callback, when the server started listening


server.listen(8000, "127.0.0.1", () => {
  console.log("listening on port 8000");
});
//we can just write localhost instead of 127.0.0.1


NODE net Ninja
Node allows to write js cose not only in server side, but also inside computer, outside the browser
1 difference is that in node the grobal object is not window obj, byt is is called global obj)
Therea re several methods to acces the GO.
console.log(global);
We will see the GO which has different methods like settimeout
global.setTimeout(....), which we can run without putting global first, like with window.setTmeout()..
__dirname is a special global var in node js-> return an absolute path of the current direction,  in my case-> D:\node
__filename returns direction with current filename->D:\node\index.js

Modules & Require
In one file 
Const something=[1, 2, 3]
module.exports=something;
In another file
const getData = require("./constant.js");-> [1,2,3]


If we hawe many exports
const something =[1, 2, 3]
const anotherthing = [11, 22, 33];


module.exports = {something, anotherthing}
And in the file
const getData = require("./constant.js");
console.log(getData.anotherthing);
Or destructure
const {something, anotherthing} = require("./constant.js");


Os
Const os =require(‘os’) -> operating system
console.log(os.platform());-> win32
console.log(os.platform());-> C:\Users\USER (my home directory)
It is very important for server side code to be able to create, read, write and create/delete directories, files, thats why node has fyle system(FS)
read
fs.readFile("./docs/blog1.txt", (er, data) => {
  if (er) {
    console.log("error", er);
    return;
  }
  console.log("data", data.toString());
}); //this method is async, and the 2 arg will work after reading is over
Function has 2 ars, first one is errr!
Write
fs.writeFile("./docs/blog1.txt", "changed text", () => {
  console.log("we wrote the file");
}); // 3 arg -> path of the file, context that we want to add, and callback
If the file does not exist(blog1.txt) it will not throw an error, butwill create an write within it
Add a directory and remove (mkdir, rmdir)
fs.mkdir("./newFolder", (err) => {  //if a folder already exists->err
  if(err){
  console.log(err);
  return;
  }
  console.log("directory created");
});
We can wrap this in if statement 
fs.existsSync("./newfolder")-> return true is exists
if(!fs.existsSync("./newfolder")){
………………
}else{
fs.rmdir()
}
Remove file
if (fs.existsSync("./docs/blog1.txt")) {
  fs.unlink("./docs/blog1.txt", (err) => {
    if (err) {
      console.log(err);
      return;
    }
    console.log("file removed");
  });
}
What if we need to read and write large files?

here->
data->buffer->browser
When buffer fills in it sends to the browser and another part of the data starts to fill in the buffer.
Interview JS/React js
1)Difference between foreach and map
1.
const map=arr.map((item)=>item+2)
const forEach=arr.forEach((item)=>item+2)
If we log map and forEach, map will return new arr-> const map,
forEach will return nothing
forEach is used to modify prev array->
const forEach=arr.forEach((item, i)=>arr[i]=item[i]+1)
2. Difference is that with map we can chain other methods, because it returns new arr`
….filter()

1a)Difference between null and undefined
null is an actual value(typeof null is obj)
undefined-> var is declared but nor initialized(typeof undefined is undefinedj)

2)Explain event delegation:
Event delegation is a technique used in web development to optimize event handling by attaching event listeners to a higher-level parent element, rather than individual child elements. When an event occurs on a child element, the event is captured by the parent element's event listener and handled accordingly.

<ul id="itemList"> <li>Item 1</li> <li>Item 2</li> <li>Item 3</li> <!-- more list items... --> </ul>
const itemList = document.getElementById('itemList');
// Attach a click event listener to the parent element
itemList.addEventListener('click', function(event) {
  // Check if the clicked target is a list item
  if (event.target.tagName === 'LI') {
    console.log('Clicked item:', event.target.textContent);
window.location.href=event.target.txtcontent
    // Additional logic here...
  }
//Inside of event object there is target property which has tagname, textcontent ……
});


3)Curried functions
In JavaScript, a curried function is a function that returns another function with some of its arguments pre-filled, allowing you to create more specialized functions from a generic function. It's a technique used in functional programming to create reusable and composable functions.

function add(x) {
  return function(y) {
    return x + y;
  }
}
INSTEAD of func above we can simply write
const add = (x) => (y) => console.log(x + y);


const add5 = add(5); // Returns a function that takes one argument
const result = add5(3); // Returns 8
INSTEAD the two lines above, we could simply 
  add(5)(3);
Or`
 const add = (x) => (y) => (z) => console.log(x + y + z);
add(5)(3)(10);

4)create a function which gets arr and el as args, and inserts the element into the end of the arr. But without modifying the arra. So we can not use push method, which does not return a new array, instead modifies our prev arr.
 const append = (array, x) => {
        return [...array, x];
      };


5.What is CI/CD?
CI/CD stands for Continuous Integration and Continuous Deployment. It refers to a set of practices in software development that involve automatically building, testing, and deploying software changes to production. Example Netlify, AWS CodePipeline, travis….: 
Continuous Integration (CI) is the practice of frequently merging code changes from multiple developers into a shared repository, and automatically building and testing the integrated code to detect and resolve integration issues. T

6.What is google cloud environment?
refers to the cloud computing platform offered by Google, known as Google Cloud Platform (GCP). It provides a wide range of cloud-based infrastructure and services that enable organizations to build, deploy, and manage various types of applications and services in a scalable, secure, and reliable manner.

7.find all vowels in the string?
onst vowels = ["a", "o", "i", "e", "u"];
      const findVowelsNumber = (str) => {
        const numVowels = str.split("").reduce((acc, el) => {
          vowels.includes(el) && acc++;
          return acc;
        }, 0);
        console.log(numVowels);
      };
      findVowelsNumber("ahgf isbcjscnk eaaa");

8. Reverse every single word in the sentence
const sentence = "Reverse every single word in the sentence";
Function..
return string.split(" ").map((el) => el.split("").reverse().join(""));

9.Define a function that takes an array of strings and return the most commonly occurring string in that array
const occurrences = myArr.reduce((acc, el) => {
        if (myArr.includes(el)) {
          if (!acc[el]) {
            acc[el] = 0;
          }
          acc[el] += 1;
        }
//instead we could write just acc[el] = acc[el] ? acc[el] + 1 : 1;


        return acc;
      }, {});
We are getting an object like->{“apple”:2, “something:3…}
  const frequent = Object.entries(occurrences).reduce(
        (acc, el) => {
          if (el[1] > acc[1]) {
            acc = el;
          } 
          return acc;
//instead we could just write return el[1]>acc[1]?el:acc
        },
        [null, 0]
      );

10 Require vs Import
Main difference is that require is just a function, thats why we can write inside conditions
Every file in JS is my default a module
module.exports=smth -> in one file
assign-> const smth=require‘./foo’-> in another file
Require method doesn’t work on the browser.It needs some library
It is typical for node.js applications. that ‘s why if we have a foo.js file`
const getFullname = (name, surname) => name + " " + surname;
module.exports = getFullname;
And in the another file`
const getFullName = require("./foo");
console.log(getFullName("john", "Doe"));
And the result of console log we can see not in the browser, but in the terminal, by writing-> node source.js

If we need multiple exports by the same file->
const getFullname = (name, surname) => name + " " + surname;
const getSurname = (surname) => surname;


module.exports = { getFullname, getSurname };
Or we can without module.exports just write->
exports.getFullname = (name, surname) => name + " " + surname;
exports.getSurname = (surname) => surname;

const foo = require("./foo");
console.log(foo.getFullname("john", "Doe"));
console.log(foo.getSurname("Doe"));


A better approach should be destructuring
const { getFullname, getSurname } = require("./foo");
console.log(getFullname("john", "Doe"));
console.log(getSurname("Doe"));


We can call require inside conditions or functions.
if (2 > 1) {
  const foo = require("./foo");
  console.log(foo.getFullname("john", "Doe"));
  console.log(foo.getSurname("Doe"));
} consols we also must write inside if block, coz foo const is declared there in has block scope.

Es6 introduces ES6 modules which work within browsers
Const getFullname = (name, surname) => name + " " + surname;
export defaultgetFullname 


import getFullname from "./foo";
console.log(getFullname("john", "Doe"));
In html file we should add to script type=”module”
<script src=’source.js type=’module”></script>
But now we have CORS error, coz in URL we see that we have just a file opened, not server
If we have npm i -g serve or go live if we have live server extension installed
Ex6 modules with node Js are difficult to use, with special tools, thats why common require func is used

What is React.js and how does it work?
Answer: React.js is a JavaScript library for building user interfaces, particularly for web applications. It allows developers to create reusable UI components that are efficient, fast, and easy to maintain. React.js uses a virtual DOM to optimize rendering performance and updates only the parts of the UI that have changed, making it highly efficient.
What are the key features of React.js?
Answer: The key features of React.js are:
Component-based architecture: React.js follows a component-based approach where UIs are built using reusable and composable components.
Virtual DOM: React.js uses a virtual DOM to optimize rendering performance and minimize updates to the actual DOM.
One-way data flow: React.js follows a unidirectional data flow, where data flows from parent components to child components through props.
JSX: React.js allows developers to write JSX (JavaScript XML) which is a syntax extension for JavaScript, making it easier to write UI components.
React hooks: React.js introduced hooks, which are functions that allow developers to use state and other React features without writing class components.
Server-side rendering: React.js supports server-side rendering, which improves the performance and SEO of web applications.
Explain the concept of virtual DOM in React.js and how it helps in performance optimization.
Answer: Virtual DOM is a lightweight in-memory representation of the actual DOM (Document Object Model) that React.js uses to optimize rendering performance. When a component's state or props change, React.js updates the virtual DOM, calculates the difference between the current and new virtual DOM, and then applies only the necessary changes to the actual DOM. This minimizes the number of updates to the actual DOM, resulting in improved performance as compared to directly manipulating the DOM.
What are the differences between Class Components and Functional Components in React.js?
Answer: Some key differences between Class Components and Functional Components in React.js are:
Syntax: Class Components are defined using the class syntax, while Functional Components are defined using a function syntax.
State management: Class Components have a built-in state management system and lifecycle methods, while Functional Components do not have state or lifecycle methods by default, but can use React hooks for state management.
Code complexity: Class Components tend to have more boilerplate code, such as constructor, render, and lifecycle methods, while Functional Components are typically more concise and easier to understand.
Performance: Functional Components with React hooks are generally more performant than Class Components, as they avoid unnecessary re-renders and allow for better optimization.
Use cases: Functional Components are recommended for most use cases, while Class Components may still be used in legacy codebases or when interacting with third-party libraries that require class-based components.
What is JSX in React.js and how does it differ from regular JavaScript?
Answer: JSX (JavaScript XML) is a syntax extension for JavaScript that allows developers to write XML-like code directly in JavaScript for defining UI components in React.js. JSX is used to create a tree of React elements, which are then rendered into the actual DOM. JSX is not regular JavaScript, but it gets transformed into JavaScript during the build process using a transpiler like Babel. JSX makes it easier to write and understand UI components in React.js, as it closely resembles HTML.
Explain the concept of props and state in React.js and their differences.
Answer: Props (short for properties) and state are two important concepts in React.js for managing and passing data between components:
Props are used for passing data from parent to child components, while state is used for managing internal mutable data within a component.
Props are immutable and set by the parent component, while state is mutable and managed by the component itself.
Props are used for communication between components, while state is used for managing local component-specific data.
Props are read-only, while state can be updated using setState() method.
Props are used for providing data and behavior to child components, while state is used for managing the internal state of a component.

7.What is React component lifecycle and what are the different lifecycle methods?
In React versions prior to 16.3, there were a set of lifecycle methods that were used to handle different phases in the lifecycle of a component. However, with the introduction of React 16.3 and above, many of these lifecycle methods have been deprecated or replaced with newer alternatives using hooks. Here is an overview of the different lifecycle methods in React:
1. **Mounting:**
   - `constructor`: This is called when a component is first created. It is used to initialize the state and bind event handlers.
   - `static getDerivedStateFromProps`: This is called when a component is first created, as well as whenever it receives new props. It is used to update the state based on the new props.
   - `render`: This is called to render the component's UI to the DOM.
   - `componentDidMount`: This is called after the component has been rendered to the DOM. It is used to perform side effects, such as data fetching or DOM manipulation.
2. **Updating:**
   - `static getDerivedStateFromProps`: As mentioned earlier, this is also called during the updating phase, when a component receives new props.
   - `shouldComponentUpdate`: This is called before a component is updated, and it allows you to control whether the component should re-render or not, based on the changes in props or state. It can be used for performance optimization.
   - `render`: This is called to re-render the component's UI to the DOM.
   - `componentDidUpdate`: This is called after the component has been updated in the DOM. It is used to perform side effects after an update.
3. **Unmounting:**
   - `componentWillUnmount`: This is called just before a component is removed from the DOM. It is used to perform cleanup tasks, such as unsubscribing from event listeners or cancelling asynchronous tasks.
4. **Error Handling:**
   - `componentDidCatch`: This is called when an error occurs during rendering, in any of the child components of a component. It is used to handle errors and display an error UI.
It's important to note that many of these lifecycle methods have been deprecated or replaced with newer alternatives using hooks in React 16.3 and above. For example, `componentWillMount`, `componentWillUpdate`, and `componentWillReceiveProps` have been deprecated, and `componentDidMount`, `componentDidUpdate`, and `componentWillUnmount` can be replaced with equivalent functionality using hooks like `useEffect` or `useLayoutEffect`. It's recommended to use hooks for managing component lifecycle in modern React applications.
8.What is the significance of keys in React.js and why are they important?
In React.js, keys are special attributes that are used to uniquely identify elements in a list or an array of child components. Keys play a crucial role in the performance and reconciliation process of React's virtual DOM. Here are some key points about the significance of keys in React:
Efficient Updating of Components: When a list of components is rendered in React, it needs to efficiently update and reconcile the differences between the new list and the previous list. React uses a process called "reconciliation" to achieve this. Keys help React identify the differences between the new and previous list of components efficiently, and only update the necessary components that have changed. 
Preserving Component State: React components can have internal state that can change over time. When a list of components is re-rendered, React uses the keys to determine which components should be preserved with their state, and which components should be unmounted and remounted. If keys are not used or not unique, React may mistakenly unmount and remount components, causing loss of component state and potential performance issues.
Stable Component Identity: Keys provide a stable and unique identity to each component in a list. This helps React maintain the correct component order and avoid issues with component reordering, especially when components are added, removed, or reordered dynamically. Without keys, React may have to rely solely on the component order, which can lead to unexpected behavior and performance issues.
Optimizing Animations and Transitions: When animating or transitioning components in a list, keys can help in optimizing the animations and transitions. With unique keys, React can accurately determine which components have changed, and apply animations or transitions only to those components, while leaving the unchanged components untouched. This helps in improving the performance and smoothness of animations and transitions in React applications.


9.What are React hooks? Explain some commonly used hooks in React
React Hooks are functions that allow you to use state and lifecycle features in functional components, which are also known as "functional components with hooks". Hooks were introduced in React 16.8 as a way to write stateful logic in functional components without the need for class components. They provide a more concise and readable way to manage state and side effects in React applications.
10.Explain the concept of "lifting state up" and "prop drilling" in React.js.
"Lifting state up" refers to the process of moving state from a child component up to its parent component. By doing so, multiple child components can share the same state and communicate changes to that state through callbacks passed down from the parent. 
On the other hand, "prop drilling" refers to the process of passing down props from a parent component to a deeply nested child component, even if some intermediate components do not need those props. This can lead to "prop pollution" and make the code harder to maintain.
11.What is Redux and how does it work with React.js? Explain the key components of Redux.
Redux is a predictable state container for JavaScript apps, which can be used with React.js or any other view library or framework. It provides a central store to manage the state of an application, making it easy to manage complex application states, handle state changes, and track the history of state changes.
Redux follows a strict unidirectional data flow architecture, which means that the state of the application can only be modified by dispatching an action to a reducer function. The reducer function receives the current state and the action dispatched, and returns a new state based on the action type and payload.
The key components of Redux are:
Store: The store is a plain JavaScript object that holds the entire state of the application. It is the single source of truth that all components access to get the current state and dispatch actions to change the state.
Action: An action is a plain JavaScript object that describes an event that occurred in the application, typically a user interaction or a network response. It contains a type property that indicates the type of action, and an optional payload property that carries any additional data.
Reducer: A reducer is a pure function that takes the current state and an action as arguments, and returns a new state based on the action type and payload. It should not modify the original state, but return a new state object.
Dispatch: Dispatch is a method provided by the store object that allows components to dispatch actions to the store. When an action is dispatched, the store calls the reducer function with the current state and the action, and returns the new state.
Middleware: Middleware is a function that can intercept and modify actions before they reach the reducer, or handle side effects such as asynchronous API calls. It provides a way to add additional functionality to the store without modifying the core Redux code.
In React.js, Redux can be integrated with the application using the react-redux library, which provides bindings for using Redux with React components. The key component provided by react-redux is the Provider, which wraps the root component of the application and passes the store down to all child components. Other key components include the connect function, which connects a component to the store and maps the state and actions to props, and the useSelector and useDispatch hooks, which provide a simplified way to access the store state and dispatch actions from within functional components.
12.What are Higher Order Components (HOCs) in React.js and how do they work?
Higher Order Components (HOCs) are a pattern in React.js that allows the reusability of component logic. They are functions that take a component as an argument and return a new component with some additional functionality.
HOCs can be used to add common functionality to multiple components, such as adding authentication, routing, or event handling. They can also be used to wrap components with shared behavior, such as animations, data fetching, or styling.
Here is an example of a HOC that adds some additional props and behavior to a component:
13.Explain the concept of "controlled components" and "uncontrolled components" in React.js.
14 How do you optimize performance in React.js applications?
15.What are some best practices for writing efficient and maintainable code in React.js?
16 what design patterns do you use in react?
MVC design pattern can also be used in frontend, where models are for components carrying the state, stateful
View is for dummy components, responsible for only the UI
Ans controllers are for business login, controlling component, that keep state within.

Difference between token and jwt token.
A token is a piece of data that represents the authorization to access a resource or perform an action. It is usually a string of characters that is generated by an authentication server and passed to the client.

JWT stands for JSON Web Token, which is a type of token that is encoded as a JSON object. It is a compact, self-contained way of transmitting information between parties as a JSON object, which can be easily verified and trusted. 

The main difference between a token and a JWT token is that a JWT token is a specific format of token that includes additional information such as an expiration time and digital signature, which makes it more secure and verifiable than a regular token. A JWT token typically consists of three parts: a header, a payload, and a signature. 

The header contains information about the type of token and the algorithm used to sign it. The payload contains the actual data being transmitted, such as user ID or permissions. The signature is generated using a secret key known only to the server, and is used to verify the integrity of the token.

In summary, JWT tokens are a type of token that include additional security features, such as encryption and digital signatures, that make them more secure and reliable than regular tokens.

On my portfolio project I added 
npm i @emailjs/browser, 
@fortawesome/free-brands-svg-icons (font with r`fortawesome)
@fortawesome/free-solid-svg-icons
@fortawesome/react-fontawesome
animate.css
gsap-trial -> more advanced animation package
loaders.css
react-leaflet ->map
React-loaders  -> to integrate loader with react
react-router-dom
Sass

https://www.freepik.com/ from the site was able to download logo
<a rel=”noreferrer”/> By using "noreferrer", the browser will not send this information to the server of the linked page, which can help protect the user's privacy.
Put sound by checking the checkbox and pause after unchecking
import sound from '../../assets/sound/sound.mp3';
const [isChecked, setIsChecked] = useState(false);
  const [audio] = useState(new Audio(sound));


  useEffect(() => {
    if (isChecked) {
      audio.play();
    } else {
      audio.pause();
      audio.currentTime = 0;
    }
  }, [isChecked, audio]);


Email JS library
-Register account on email.js
-+add services-> gmail-> connec to account(aaa@nmm..)
- added service withgiven id ->service_oorr7dp.. Which we can change.
-create a template

https://www.emailjs.com/docs/examples/reactjs/ Documents-um integrationy ka

Mer file-um namery inputneri poxum enq
Key-ery dnum enq. 'YOUR_PUBLIC_KEY' key-y gtnum enq account-um

emailjs.sendForm('YOUR_SERVICE_ID', 'YOUR_TEMPLATE_ID', form.current, 'YOUR_PUBLIC_KEY')
      .then((result) => {
          console.log(result.text);
      }, (error) => {
          console.log(error.text);
      });
  };

import { useState, useRef } from 'react';
import emailjs from '@emailjs/browser';
import { ToastContainer, toast } from 'react-toastify';


const Form = () => {
  const [valid, setValid] = useState(false);
  const form = useRef(null);
  const name = useRef(null);
  const email = useRef(null);
  const subject = useRef(null);
  const text = useRef(null);


  const sendEmail = (e) => {
    e.preventDefault();


    emailjs
      .sendForm(
        'service_ArmineEmailPorfo',
        'template_vfae0id',
        form.current,
        '7QHghtyZK0RVR-sDe'
      )
      .then(
        (result) => {
          console.log(result);
          toast('Thank you for reaching out! Your message has been sent.', {
            type: 'info',
          });
          form.current.reset();
        },
        (error) => {
          console.log(error.text);
          toast('Something went wrong. Please try again!', {
            type: 'warning',
          });
        }
      );
  };
  const checkValidFields = () => {
    name.current.value &&
    subject.current.value &&
    text.current.value &&
    email.current.value.match(/^[^\s@]+@[^\s@]+\.[^\s@]+$/)
      ? setValid(true)
      : setValid(false);
  };
  return (
    <div className="contact-form">
      <form ref={form} onSubmit={sendEmail}>
        <ul>
          <li className="short">
            <input
              ref={name}
              type="text"
              name="user_name"
              placeholder="Name"
              onChange={checkValidFields}
            />
          </li>
          <li className="short ml">
            <input
              ref={email}
              type="email"
              name="user_email"
              placeholder="Email"
              onChange={checkValidFields}
            />
          </li>
          <li>
            <input
              ref={subject}
              type="text"
              name="subject"
              placeholder="Subject"
              onChange={checkValidFields}
            />
          </li>
          <li>
            <textarea
              ref={text}
              placeholder="Message"
              name="message"
              onChange={checkValidFields}
            ></textarea>
          </li>
          <div className={`custom-btn ${valid && 'active'}`}>
            <button type="submit">Send</button>
          </div>
        </ul>
      </form>
      <ToastContainer
        className="toast"
        position="top-center"
        pauseOnHover
        autoClose={7000}
      />
    </div>
  );
};


export default Form;



react-leaflet ->map wasn’t able to change the language.
Google maps
npm install @react-google-maps/api
https://console.cloud.google.com/cloud-resource-manager -ov delete em anum naxord proektnery->services and apis

->create credentials-> create a new api key
AIzaSyA0V7rkqGAS2BTpDNiJCK6t4bUYPsR-_SQ     MY API KEY
For created project Profile6246

We should enable the key-> library(there are 17 maps around)we need to choose maps JS Api-> enable
Place Api-> enable
Directions Api->enable
Geolocation Api, Geocoding Api -> enable

The key should be kept in .env file
Rules for .env vars
1.should be in the root of the roject
2.should start with REACT_APP…
3.should be accessed like-> process.env.REACT_APP_MAP_API_KEY,
import { useMemo } from 'react';
import {
  GoogleMap,
  Marker,
  useLoadScript,
} from '@react-google-maps/api';


const Map = () => {
  const position = useMemo(() => ({ lat: 40.1872, lng: 44.5152 }), []);
  const { isLoaded } = useLoadScript({
    googleMapsApiKey: process.env.REACT_APP_MAP_API_KEY,
  });
  return (
    <>
      {isLoaded && (
        <GoogleMap zoom={10} center={position} mapContainerClassName="map-cont">
          <Marker position={position} />
        </GoogleMap>
      )}
    </>
  );
};
export default Map;

DEPLOY the proeject with netlify
https://www.youtube.com/watch?v=tVzpC5_AC8M
Manual-i depqum drag and drop enq anum miayn buid folder-y
Update-i hamar deploys tab-> trigger deploy
Netlify is a popular CI/CD tool that is often used for deploying static websites, Jamstack applications, and serverless functions. Netlify provides an all-in-one platform for building, deploying, and managing web projects, with features such as continuous deployment, version control, and automatic HTTPS.
With Netlify, developers can connect their code repository to their Netlify account and set up automated deployments based on triggers such as code commits or pull requests. Netlify can also integrate with other tools in the developer's workflow, such as GitHub, Bitbucket, and Slack.
One of the benefits of using Netlify is its simplicity and ease of use. Developers can deploy their applications in just a few clicks, without needing to configure complex build pipelines or infrastructure. Netlify also provides a global content delivery network (CDN) and automatic asset optimization, which can help improve the performance and scalability of web applications.
What is next.js
Next.js is a React-based framework for building web applications that offers server-side rendering, static site generation, and client-side rendering capabilities. It was created by Zeit, and is now an open-source project supported by Vercel.
Next.js provides several features to help developers build modern web applications, such as:
Server-side rendering: Next.js allows developers to render React components on the server, making it possible to load web pages faster and improve SEO.
Static site generation: Next.js can generate static HTML files at build time, which can be served directly from a CDN. This allows for extremely fast loading times, as there's no need to render pages on the server or generate HTML dynamically.
Automatic code splitting: Next.js automatically splits code into smaller chunks that can be loaded on demand, reducing the initial load time of your application.
API routes: Next.js makes it easy to create API endpoints that can be accessed from both the client and server.
Built-in CSS support: Next.js supports CSS modules out of the box, making it easy to write modular and reusable CSS code.
Overall, Next.js is a powerful and flexible framework that allows developers to build performant and scalable web applications with ease.
While both Next.js and react-router-dom can be used to build web applications with React, they serve different purposes. Next.js provides a more complete solution for building full-stack React applications, whereas react-router-dom is focused solely on client-side routing.
In fact, Next.js actually includes its own routing system, which allows you to define dynamic routes and handle server-side rendering of those routes, among other features. So, you could say that Next.js includes react-router-dom-like functionality, but also offers a lot more on top of that.
Next.js is a React-based framework for building web applications that provides server-side rendering, static site generation, and client-side rendering capabilities. It offers a set of features for building full-stack React applications with ease, including automatic code splitting, built-in CSS support, and API routes.

